## string

redis的string是一个==**可变**==的字节数组，使用一种SDS的抽象数据类型表示，里面包括了字符串的长度、字符串的每个元素和未使用的字节数量。对其可以得到长度、获取字串、覆盖字串内容、追加字串等。

SDS：使用char数组来保存字符串，并且使用len作为属性直接记录字符串的长度。char数组使用'\0'结尾，使得SDS可以直接重用一部分C字符串函数库里面的函数。

好处：可以使用常数时间获取字符串长度；杜绝缓冲区溢出的可能性，如果不满足，API会自动将SDS的空间扩展至执行修改所需的大小；兼容部分C字符串函数。

* 扩容：字符串长度小于1M时，每次扩容都是加倍现有空间。大于1M时，每次扩容只会多扩容1M的空间。**最大长度为512M**。
* 惰性释放：移除部分字符时，多出来的空间不会直接释放，而是留着给下一次字符的分配使用。
* 二进制安全：SDS遇到空字符不会立刻结束，而是根据len来判断是不是真的结束了。避免遗漏了后面的字符。
* 计数器：如果字符串的内容是一个整数，还可以将字符串当成计数器使用。计数器同样有范围。
  * `incrby names 100` 增加100 
  * `incr ireader` 自增1 

**应用**：String是最常用的数据类型，普通的key/value都可以归为此类。String还可以作为一个整数，能够进行一些自增、自减操作。能够做分布式锁`set nx`。



## list

list的存储结构使用的是双向链表，因此它的随即定位性能较弱，首尾插入删除的性能比较优秀。

负下标：链表元素的位置可以使用负数表示，此时获取的就是倒数第i位的元素。

队列/堆栈：可以使用`lpush`、`lpop`、`rpush`、`rpop`的方式对列表在两端进行元素的增加与删除。

extends：获取长度、指定位置访问、修改元素、指定元素的前后方插入新元素、根据元素名删除元素。

**快速列表**：在列表元素较少的情况下使用ziplist存储，此时分配的是一块连续的内存。数据量较多时才会改成quicklist(将多个ziplist使用双向指针串起来，节省一定空间)。

**应用**：可以作为消息队列，利用push的操作，将任务存储在list中，然后工作线程再用pop操作将任务取出进行执行。

### ziplist

当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，redis就会使用压缩列表来做列表键的底层实现。

当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。

构成：压缩表是一系列特殊编码的连续内存块组成的顺序型数据结构。

| zlbytes | zltail | zllen | entry1 | entry2 | ...... | entryN | zlend |
| ------- | ------ | ----- | ------ | ------ | ------ | ------ | ----- |

每个节点(entry)都由previous_entry_length(前一个结点的长度)、encoding(当前节点的数据类型和长度)、content(节点的值)三个部分组成。

==**连锁更新**==：插入了一个新的节点，会导致previous_entry_length的变化，可能会使得后续每一个节点的该属性都由1字节(具体值<256)变为5字节，为了让每个节点的previous_entry_length属性都符合压缩列表对节点的要求，程序需要不断地 对压缩列表执行空间重分配操作，直到eN为止。



## hash

hash结构的key需要是唯一值，value其实也是一个map结构(套娃)，特别适合用于存储对象。

等价于java中的HashMap，在结构上使用的是数组+链表的方式。长度同HashMap，初始16。

扩容：申请新的2倍大小的数组，然后把所有的键值对重新rehash到新的数组中。

缩容：原理和扩容一致，新的数组大小要比旧数组小一倍。

**应用**：可以用来存储一个用户的信息。key为查找的唯一标识，如id。value可以包括用户的各种信息，名字，性别等。



## set

内部使用的是hash结构，但是所有的value对应的是一个key。

类似于list，但是set可以自动排重，set中的元素是不重复的元素。

能够进行求交集、并集、差集等操作。

**应用**：比如在微博应用中，每个人的好友存在一个集合中，这样求两个人的共同好友的操作，就能使用求交集的命令。



## sortedset(zset)

一个非常特别的数据结构，一方面等价于Java的Map<String,Double>，可以给每一个元素一个权重，另一方面又类似于`TreeSet`，内部的元素会按照权重进行排序，可以得到每个元素的名次，还可以通过权重的范围获取元素列表。



数据结构

* hash：用于关联元素value和权重score，保证value的唯一性。
* 跳跃列表：给value排序，根据score的范围获取列表。
  * 跳跃列表类似于层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。
  * 跳跃表的每一层都是一个有序的链表，链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点。

![img](https://user-gold-cdn.xitu.io/2018/7/23/164c5bb13c6da230?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



**应用**：twitter的public timeline可以以发表时间作为score来存储，这样获取的时候就是按照时间自动排好序的。或者可以作为带权重的队列，让重要的任务先执行。

## bitmap





## quicklist

结构体跟链表的结构体类似，都包含了表头和表尾。每一个quicklistNode中有一个指向压缩列表的指针。

添加元素时会先检查相应位置的quicklistNode的压缩列表是否容得下，**不能才会创建新节点**。

会控制每个节点中压缩列表的大小或者元素个数，来规避连锁更新的风险。



## listpack

设计目的是为了代替压缩列表，listpack中每个节点不再包含前一个节点的长度(避免连锁更新)。

**==依然采用连续的内存空间来紧凑地保存数据==**。每个listpack节点中的具体结构为：编码类型、实际数据、节点总长度。

