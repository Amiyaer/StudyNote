## redis的作用

除了做缓存外，也经常用来做**分布式锁**，甚至是**消息队列**。

为什么要使用缓存：高频数据从磁盘中读取速度较慢，如果是放在内存中速度相当快。

要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，要同步改变缓存中相应的数据。

其他(举例)：

1. 记录帖子的点赞数、评论数和点击数 (hash)。
2. 记录用户的帖子 ID 列表 (排序)，便于快速显示用户的帖子列表 (zset)。
3. 记录帖子的标题、摘要、作者和封面信息，用于列表页展示 (hash)。
4. 记录帖子的点赞用户 ID 列表，评论 ID 列表，用于显示和去重计数 (zset)。
5. 缓存近期热帖内容 (帖子内容空间占用比较大)，减少数据库压力 (hash)。
6. 记录帖子的相关文章 ID，根据内容推荐相关帖子 (list)。
7. 如果帖子 ID 是整数自增的，可以使用 Redis 来分配帖子 ID(计数器)。
8. 收藏集和帖子之间的关系 (zset)。
9. 记录热榜帖子 ID 列表，总热榜和分类热榜 (zset)。
10. 缓存用户行为历史，进行恶意行为过滤 (zset,hash)。



## redis和Memcache的区别和共同点

### 共同点

1. 都是基于内存的数据库，一般都用来当作缓存使用。
2. 都有过期策略。
3. 两者的性能都非常高。



### 不同点

| Redis                                                 | Memcache                         |
| ----------------------------------------------------- | -------------------------------- |
| 支持更丰富的数据类型                                  | 只支持最简单的k/v                |
| 支持数据持久化                                        | 不支持持久化                     |
| 有灾难恢复机制                                        | 无                               |
| 在服务器内存不够时，可以将不用的数据放到磁盘上        | 内存不够直接报错                 |
| 原生支持集群                                          | 没有原生集群，需要依靠客户端实现 |
| 单线程，多路IO复用(6.0引入多线程)                     | 多线程，非阻塞IO复用             |
| 支持发布订阅模型、Lua脚本、事务等。支持更多编程语言。 | 不支持                           |
| 对于过期数据，同时使用惰性删除与定期删除              | 只使用惰性删除                   |



## redis为什么不使用多线程

1. 单线程更容易维护。
2. **redis的性能瓶颈不在于CPU**，多线程是在CPU层面改善性能。
   1. redis并不是CPU密集型的服务，如果不开启AOF，所有Redis的操作都会**在内存中完成**不会涉及任何的IO操作。这些数据的读写由于只发生在内存中，所以处理速度是非常快的。整个服务的瓶颈在于网络IO，多线程模型处理全部的外部请求可能不是一个好的方案。
3. 多线程存在死锁和上下文切换的问题，甚至反而会影响性能。



## redis的单线程模型

基于**Reactor模式**来设计开发了自己的一套高效的事件处理模型。这套时间处理模型对应的是Redis中的**文件事件处理器**。由于文件时间处理器是单线程方式运行的，所以一般都说redis是单线程模型。



redis通过IO多路复用程序来监听来自客户端的大量连接(多个socket)，它会将感兴趣的事件及类型注册到内核中并监听每个事件是否发生(监听多个文件描述符的可读和可写状态)。一旦收到网络请求就会在内存中快速处理，在内存中处理速度会非常的快。



## redis过期数据的删除策略

redis可以给数据设置过期时间。

对于过期的数据，有两个删除策略：

- **惰性删除**：只会在取出key的时候才对数据进行过期检查。可能会造成太多过期key没有被删除。对内存较友好。
- **定期删除**：每隔一段时间抽取一批key执行过期删除操作。redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。对CPU较友好。

使用这两种删除策略还是可能存在漏掉了很多过期key的情况。可以通过redis的内存淘汰机制来解决这个问题。



## redis内存淘汰机制

redis提供6种数据淘汰策略：

`volatile-lru`：淘汰最近最少使用的数据(已设置过期时间)。

`volatile-ttl`：淘汰将要过期的数据(已设置过期时间)。

`volatile-random`：任意选择数据淘汰(已设置过期时间)。

`allkeys-lru`：当内存不足以容纳写入新数据时，在键空间中移除最近最少使用的key。

`allkeys-random`：从数据集中任意选择数据淘汰。

`no-eviction`：禁止淘汰数据，内存不够就报错。

`volatile-lfu`：淘汰最不经常使用的数据(已设置过期时间)。

`allkeys-lfu`：内存不足时，在键空间中移除最不经常使用的key。





## 如何保证缓存与数据库一致性

Cache Aside Patten：读的时候，先读缓存，缓存没有就读数据库，然后更新缓存并返回响应；更新的时候，**先更新数据库，再删除缓存**。



**为什么是删除缓存而不是更新缓存**：

* 缓存有时候可能是复杂的值，需要多个表中的值计算。
* 有时候某个被缓存的数据**==更新非常频繁而查询不太频繁==**，如果只是删除缓存，就只需要在查询的时候计算一次。用到缓存才去算缓存。



**缓存删除失败(数据库中新数据，缓存中旧数据)怎么办**：

* 先删除缓存再更新数据库。
* **==延时双删==**：删除操作在一段时间后再次执行一次。删除的指令可以有多种选择(MQ等)。



### 复杂情况

先删除缓存，后修改数据库。**没来得及修改数据库就有查询过来**，由于缓存没有数据，去查数据库查到了旧消息。然后数据库完成修改。此时缓存和数据库中数据**不一致**。

解决方法：使用内存队列保证串行化。？

