# 一 可靠、可扩展与可维护的应用系统

数据密集型应用→限制性因素关键在于**数据量**、数据复杂度、数据快速多变性。

核心设计目标：可靠、可扩展与可维护的数据系统。



**数据系统**：数据库、队列、高速缓存等系统。应用系统需求广泛，单个组件往往无法满足所有数据处理与存储需求。因此需要将**任务分解**，每个组件负责高效完成其中一部分。多个组件依靠应用层代码的驱动有机衔接。(消息队列和缓存通常由应用代码负责缓存、索引与主数据库之间的同步)。

一个个通用组件→全新的、专用的数据系统。



**可靠性**：出现意外情况(故障、人为失误)，系统可以正常继续运转。

```html
- 系统应对错误→容错
- 检测可靠性：随机杀死进程。
- 软件容错：需要打补丁时可以每次给一个节点打补丁，然后重启，而不是下线整个系统。
```

**可扩展性**：系统应对负载增加的能力。随着规模(数据量、流量)的增长，系统应以合理的方式来匹配这种增长。

负载：可以用负载参数来描述，可以是每秒请求处理次数、聊天室用户数量等。

**可维护性**：随着时间的推移，许多新的人员参与到系统开发和运维，以维护现有功能或适配新场景。



---



# 二、数据模型与查询语言

数据模型叠加→应用程序。

对于复杂的应用程序，基本思路就是每层都通过提供一个简洁的数据模型来隐藏下层的复杂性(**抽象机制**)。这种抽象机制使得不同的人群可以高效协作。

## 关系模型与文档模型

**关系模型**：数据被组织成关系，在SQL中称为表，其中每个关系都是元组的无序集合。

关系数据库的核心在于商业数据处理，主要是事务处理和批处理。

对象-关系不匹配：数据存储在关系表中，应用层代码中的对象与表、行和列的数据库模型之间需要一个==笨拙的转换层==。

关系模型中一对多的关系：可以放在单独的表中，并使用外键来解决；将部分信息编码为xml文档或json文档，存储在数据库的文本列中，由应用程序解释其结构和内容。

**JSON模型**：比多表模式具有更好的局部性，对于这种表示法，所有的相关信息都在一个地方，只需要一次查询就能得到全部数据。



### 多对一和多对多的关系

让用户从下拉列表选择比自行输入更有优势，更易于更新。ID只对数据库有意义，而名字只对用户有意义。

文档模型并不是很适合多对一的关系(许多人生活在同一地区)，反而对于关系型数据库，由于支持联结操作，可以很方便通过ID来引用。查询优化器自动决定以何种顺序执行查询，使用哪些索引。这些实际上等价于**访问路径**。

文档数据库是某种方式的层次模型：在父记录中保存了==嵌套记录==，而不是存储在单独的表中。

如果应用数据具有类似文档的结构，使用文档模型更为合适。而关系型模型倾向于某种数据分解，把文档结构分解为多个表。

应用程序需要改变结构时，在文档数据库中，只需新字段来编写新文档，并在应用层处理旧文档，而对于"静态类型"数据库模式中，通常使用ALTER或UPDATE进行升级，这种方式速度慢并且需要停机。



局部性想法：将相关数据归为一组，常见于文档模型。

**查询数据局部性**：如果应用程序需要频繁访问整个文档，则存储局部性具有性能优势。这种局部性优势仅适用于需要同时访问文档大部分内容的场景。

如果应用只是访问一小部分，对于大型文档数据来说比较浪费。通常建议文档应该尽量小且避免写入时增加文档大小。





### 数据查询语言

**命令式**：类似于for循环语句，规定使用特定的顺序来执行查询操作。常见于一般程序语言。

**声明式**：只指定所需要的数据模式，而不指明查询的过程。常见于数据库系统，一般情况下，数据库系统的查询优化器会决定采用哪些索引和联结，以及用何种顺序来执行查询的各个语句。

声明式的语言比命令式API更加简洁和容易使用。对外隐藏了数据库引擎的很多实现细节，数据库系统能够在不改变查询语句的情况下提高性能。







---







# 三、数据存储与检索

存储引擎有面向页的存储引擎和面向日志结构的存储引擎两种。

## 面向日志结构的存储引擎

日志是一个仅支持追加式更新的数据文件，一般数据库中的任何数据进行了修改操作，就要有一个对日志的写操作，将数据追加到日志的末尾。

如果日志保存了大量的记录，那么数据库的get函数性能将会非常差。每次查找一个键。必须从头到尾扫描整个数据库文件来查找键的出现位置，这一点并不好。

高效查找特定键的值：**使用索引**。索引会加快查询的性能，同时也会降低写的速度，每次写数据时，都需要更新索引。

### 哈希索引

维持一个内存中的hashmap，对于追加式文件(日志)的数据存储，可以把每一个键一一映射到数据文件中**特定的字节偏移量**，这样就可以找到每个值的位置。文件中追加新的数据时，还要更新hashmap来反映刚刚写入的字节偏移量；查询某个值的时候，使用hashmap来找到文件中的偏移量(存储位置)，然后读取其内容。

使用hashmap，只需要一次磁盘寻址，就可以将value从磁盘加载到内存，如果那部分文件已经在文件系统的缓存中，那读取根本不需要任何的磁盘IO。

**避免用尽磁盘空间：将日志分解成一定大小的段**。当文件达到一定大小时就关闭它，并将后续写入到新的段文件中。然后可以在这些段上执行**压缩(丢弃重复的键，并且只保留每个键最近的更新)**。压缩时，也可以将多个段合并在一起，合并的段会被写入一个新的文件。

**每个段拥有自己的内存哈希表**，将键映射到文件的偏移量，查找时应该查找最新的段的hashmap。如果键不存在，检查第二最新的段，以此类推。

哈希索引的局限性：哈希表必须全部放入内存，如果有大量的键，内存中很可能放不下；对于区间查询效率不高，只能采用逐个查找的方式查询每一个键。

### SSTables和LSM-Tree

如果把日志结构中的存储段按key-value对的顺序按键排序，这种格式称为排序字符串表**SSTable**。它要求每个键在每个合并的段文件中**只能出现一次(压缩过程已经确保了)**。

SST具有以下优点：**合并段更加简单高效**，并发读取多个输入段文件，比较每个文件的第一个键，把**最小的键拷贝到输出文件**；文件中查找特定的键时，不需要在内存中保存所有键的索引，只需要保存一个不太大的范围即可(比如h开头)，可以找到磁盘中相应的范围，**由于是排好序的，直接顺序查找即可**。

维护SST：当写入时，将其添加到**内存中的平衡树数据结构中(内存表)**；当内存表大于某个阈值时，将其作为SST文件写入磁盘，此时的内存表是自动排好序的，写入很高效，新的SST作为数据库的最新部分；处理读请求时，**先在内存表中读取**，然后查找最新的磁盘段文件，以此类推；后期对段文件进行压缩。

如果数据库崩溃，内存中的平衡树数据结构存储的最新写入会全部丢失。为了防止这种情况，可以用一个临时磁盘文件存储。每当内存表写入SST时，相应的日志可以被丢弃。

基于合并和压缩排序文件原理的存储引擎通常都被称为LSM(日志结构的合并树)存储引擎。



## 面向块/页的存储引擎

### B-trees

WAL：预写日志。

B-trees将数据库分解为固定大小的块或页，传统上大小为4kb。页是内部读写的最小单元。

每一个页面都可以使用地址或位置进行标识，以便一个页面引用另一个页面。其中一页被指定为B-trees的根，从这里开始查找。该页面包含若干个键和对子页的引用。**每一个子页都负责一个连续范围内的键**。

添加新键：找到其范围包含的新键的页，并将其添加到该页，如果页中没有足够的可用空间来容纳新键，将其分裂成两个半满的页，并且父页也需要更新以包含分裂之后的新的键范围。

**写操作**：基本写操作是使用**==新数据覆盖==**(用新的数据覆盖相应的扇区)磁盘上的旧页，且保证当页被覆盖时，对该页的所有引用保持不变。

**恢复**：为了使数据库能够从崩溃中恢复，常见B-tree的实现需要支持磁盘上的额外的数据结构：**预写日志，也称为重做日志**。当数据库在崩溃后需要恢复时，该日志用于将B-tree恢复到最近一致的状态。

优化：一些数据库不使用覆盖页和维护WAL来进行崩溃恢复，而是使用写时复制方案：修改的页被写入不同的位置，树中父业的新版本被创建，并指向新的位置。使用B+树。







