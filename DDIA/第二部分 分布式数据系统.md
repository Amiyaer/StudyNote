需要在多台机器上分布数据：

* 读写负载大：分散到多台机器。
* 单机故障：冗余机器接管。
* 客户范围广：在各地部署服务，避免数据跨越半个地球到达目标。



复制：在多个节点上保存相同的数据的副本。

分区：将一个大块头的数据库拆成多个较小的子集——分区，不同的分区分配给不同的节点。





---







# 五、数据复制

**复制**：主要指通过互联网络在多台机器上保存相同的副本。通过复制方案，人们希望达到降低延迟、提高可用性、提高吞吐量的目的。

## 主从复制

指定一个副本为主节点，其他副本为从节点。主节点复制写入，从节点负责读取数据。

**对于主节点的每一笔写入，从节点都要进行随之进行数据更新**。

同步复制：主节点写入时，需要等待同步复制的节点确认完成写入，才会向用户报告完成，并且将最新的写入对其他客户端可见。

异步复制：主节点发送完消息后立即返回，不用等待从节点的确认。



配置新节点：做到不停机、数据服务不中断的前提下完成从节点的设置。

1. 在某个时间点产生一个主节点的数据快照，根据快照把数据拷贝到新的从节点。
2. 从节点想主节点请求快照之后发生更改的数据日志。
3. 从节点根据日志，应用这些快照点之后的所有数据变更。并继续处理主节点上新的数据变化。



节点失效：

从节点失效→得到发生故障前的最后一笔事务，连接到主节点，请求那次事务之后的数据变更日志。然后追赶主节点。

主节点失效→根据心跳存活信息确认主节点失效，选举新的主节点，重新配置系统。



### 复制日志的实现

基于语句：主节点将每个写请求执行的SQL语句最为日志的一部分，并传给从节点。

基于预写日志WAL：每个写操作以追加写的方式写入到日志中。因此可以使用完全相同的日志在另一个节点上构建副本：除了将日志写入磁盘，主节点还可以通过网络将其发送给从节点。

基于行的逻辑日志复制：逻辑日志通常指一系列记录来描述数据表**行级别**的写请求。





### 复制滞后问题 

一个应用从一个**异步的从节点读取数据**，而该副本落后于主节点，则应用可能会读到过期的信息。

#### 1.读自己的写

用户提交信息后查看自己刚提交的内容，**新数据可能尚未到达从节点**。

解决：实现写后读一致性。

* 如果用户访问可能会被修改的内容，从主节点读取。否则就在从节点读取。
* 跟踪数据最近更新时间，如果更新时间较近，在主节点读取。
* 客户端可以记住最近更新时的时间戳，并附带在读请求中。



#### 2.单调读

一个数据在两个节点上的滞后时间不同，导致同一条数据在两个节点上不一样。

解决：单调一致性读。

确保每个用户总是从固定的同一副本执行读取。



#### 3.前缀一致读

两条写请求在同一个从节点上的滞后时间不同，导致**后写入的数据反而先到达从节点**。可能会出现因果关系不一致。

分区数据库会出现的一个特殊问题，不同的分区独立运行，因此不存在全局写入顺序。

解决：确保任何具有因果顺序关系的写入都交给一个分区来完成。







## 多主节点复制

主从复制存在一个明显的缺点：系统只有一个主节点，而所有写入都必须经由主节点。

多主节点复制：配置多个主节点，每个主节点都可以接受写操作，处理写的每个主节点都必须将该数据更改转发到所有其他节点。此时，每个主节点还同时扮演其他主节点的从节点。



**适用场景**：多数据中心——为了容忍整个数据中心级别故障或者更接近用户，可以把数据库的副本横跨多个数据中心。可以在每个数据中心都配置主节点。

每个数据中心内部：主从复制；数据中心之间：各个数据中心的**主节点**负责同其他数据中心的主节点进行数据的交换。





***







# 七、事务

## 事务的一致性

ACID中的一致性主要是指对数据有特定的预期状态，任何数据更改必须满足这些状态约束(或者恒等条件)。这种一致性本质上要求应用层来维护状态一致。



## 事务隔离级别

只有出现某个事务修改数据而另一个事务同时访问/修改数据时，才会引发并发问题。



### 读-提交

提供以下保证：

* 读数据库时，只会看到已经提交的数据(防止"脏读")。
* 写数据库时，只会覆盖已经提交的数据(防止"脏写")。

防止脏写：使用行级锁来防止脏写，当事务想要修改某个对象(行)时，他需要先获得该行的锁，然后**==一直持有锁直到事务提交或中止==**。如果有另一个事务尝试==更新==同一个对象，他需要锁被释放以后才能获得锁然后继续。



### 可重复读

使用**快照级别隔离**：每个事务都从数据库的一致性快照中读取，事务一开始所看到的是最近提交的数据，即使数据随后可能被另一个事务更改，但==保证每个事务都只看到特定时间点的旧数据==。快照级别隔离的一个关键点是读操作不会阻止写操作，反之亦然。

实现**快照级别隔离**：数据库保留了对象多个不同时间的提交版本。当事务开始时，首先==**赋予一个唯一的、单调递增的事务ID**==。每当事务向数据库写入新内容时，所写的数据都会被标记写入者的事务ID。表中的每一行都有一个created_by字段和deleted_by字段，表示该行的事务ID和删除该行的事务ID。一笔更新操作会被转换为一个删除操作和一个创建操作。

可见性原则：当事务读取数据时，通过事务ID决定哪些对象可见，哪些不可见。

* 每笔事务==开始时==，数据库列出所有当时尚在进行中的其他事务(ReadView)，这些事务所做的修改全部不可见。
* 较晚的事务和中止的事务全部不可见。
* 其它事务都可见。



### 防止更新丢失

1. 原子写操作：通常是对读取对象加独占锁的方式来实现。
2. 应用层显式加锁。
3. 原子比较和设置(CAS)：如果旧值已经发生了变化，则更新失败，需要应用层再次检查并在必要时进行重试。



### 写倾斜与幻读

写倾斜：一种更广义的更新丢失。两个事务更新两(多)个对象，但是两个对象依赖于某一个变量，不能全部更新被更新。而由于两个事务同时更新，违背了这一原则，导致问题。

如果不能使用可串行化级别的隔离，一个次优的选择是对事物依赖的行来显示加锁。

所有写倾斜都遵循：查询满足条件的所有行，根据结果(==前提条件==)，应用层代码决定下一步操作；如果决定写入，会改变==前提条件==。

幻读：在一个事务中的写入改变了另一个事务的查询结果。

**快照级别隔离可以避免只读查询时的幻读，但是对于写倾斜的问题无法避免**。



### 可串行化

最强的隔离级别，保证事务可能会并行执行，但是最终的结果与串行执行结果相同。

#### 严格串行化

在一个线程上，按顺序方式每次只执行一个事务。这样就完全回避了诸如检测、防止食物冲突等问题，对应的隔离级别一定是严格串行化的。

使用存储过程：应用程序将整个事务代码作为存储过程打包到数据库，把事务所需的所有数据全部加载在内存中，使存储过程高效执行，==无需等待网络或磁盘I/O==。

#### 二阶段加锁

多个事务可以同时读取同一对象，但只要出现任何写操作，则必须加锁以独占访问。

谓词锁：并不属于某个特定对象，而是作用于==满足某些搜索条件的所有查询对象==。甚至可以保护数据库中尚不存在但可能马上会被插入的对象。

索引区间锁(next-key locking)：将锁附加到索引条目上。

#### 可串行化的快照隔离

一种乐观并发控制，事务提交时，数据库会检查是否确实发生了冲突，如果是的话，终止事务并接下来重试。

查询结果发生变化的情况：

* ==检测是否读取一个过期的MVCC对象==。当事务提交时，数据库检查是否存在一些当初被忽略的写操作已经完成了提交，如果是就必须中止当前事务。
* ==检测写入是否影响即将完成的读取==。另一个事务尝试修改某值时，首先检查索引，从而确定是否最近存在一些读目标数据的其他事务。这个过程类似于在受影响的字段范围上获取写锁，但他并不会阻塞读取，而是直到读事务提交时才进一步通知他们：所读到的数据已经发生了变化。





---

# 八、分布式系统的挑战

## 故障与部分失效





---



# 九、一致性与共识

最终的一致性：大多数多副本的数据库都最少提供了最终的一致性，这意味着如果停止更新数据库，并等待一段时间之后，最终所有的读请求会返回相同的内容。

面对只提供了弱保证性的数据库不可过于乐观，应用可能再大多数情况下都表现良好，但数据库内部可能已经发生了非常微妙的错误，只有**系统出现故障或高并发压力时**，最终一致性的错误才会暴露出来。

本章探索更强的一致性模型，这也意味着更多的代价，例如**性能降低或者容错性差**。分布式一致性主要是针对**延迟和故障**等问题来协调副本之间的状态。



## 可线性化(强一致性模型)

让一个系统看起来好像只有一个数据副本，且所有的操作都是原子的，这就是可线性化(强一致性、原子一致性)的思想。

在可线性化的系统中，一旦某个客户端成功提交写请求，**所有**客户端的读请求一定都能看到**刚刚写入的值**。

可线性化要求：在写操作前/后的读操作读到的一定是旧/新值；与写操作重叠的读操作，一部分会返回旧值，另一部分会返回新值，为了使系统可线性化，要求一旦某一个读操作返回了新值，之后**所有的读都必须返回新值**(即使写操作还在进行)。

由于请求并发和网络延迟等情况，读写请求发出的先后顺序与它们执行的先后顺序不一定一致。后发出的请求有可能先被执行完毕。



### <u>**可线性化的依赖条件/使用场景**</u> 

#### 加锁与主节点选举 

选举新的主节点通常是使用锁，成功试图获取到锁的节点为主节点。所有节点都必须同意哪个节点持有锁，否则就会出现问题。

提供协调者服务的系统如Zookeeper等通常用来实现分布式锁和主节点选举。它们都使用了支持容错的共识算法确保可线性化。

#### 约束与唯一性保证

在数据库中十分常见(唯一性的标识)，如果要在写入数据的时候强制执行唯一性约束，也需要线性化。其他类似的约束包括账户余额不应该出现负值、避免出售库存里已经没有的商品等。

这种情况与加锁类似，用户注册等同于试图对用户名进行加锁操作，该操作类似于CAS。

#### 跨通道的时间依赖

有时候线性化的违背之所以被注意到，是因为系统中**存在其他的通信渠道**。

例如：先写入文件，再对文件(图片)进行图像调整(MQ)，如果文件存储服务不是可线性化的，消息队列可能回避存储内部的复制执行更快，导致可能读取不到图像。



### 实现线性化系统

满足/不满足 线性化的方案：

* 主从复制(部分支持线性化)：如果从主节点或者**同步更新**的从节点上读取，则可以满足线性化。异步复制则不能支持。
* 共识算法(可线性化)：通常内置一些措施来防止裂脑和过期的版本。
* 多主复制(不可线性化)：同时在多个节点上执行并发写入，可能会产生冲突的写入，需要额外的解决方案。
* 无主复制(可能不可线性化)：取决于quorum的配置。

> quorum : n个副本，写入需要w个节点确认，读取必须至少读取r个节点。只需要w+r>n，读取的节点中一定会包含最新值。

对于无主复制的模型，如果读写遵从了严格quorum，应该是可线性化的。如果遭遇不确定的**网络延迟**，就会出现竞争条件(读操作时，完成的写操作节点数w1+r≤n)。

可以使无主风格的复制系统以牺牲性能为代价来满足线性化：读操作在返回结果给应用之前，必须同步执行读修复；写操作在发送结果之前，必须读取quorum节点以获取最新值。



### 线性化的代价

如果两个数据中心之间发生网络中断，客户端可以到达就近的数据中心，但数据中心之间无法互联。

基于多主节点复制的数据库，每个数据中心内部可以正常运行，一个数据中心到另一个数据中心的复制是异步，等待网络恢复再进行。

基于主从复制的数据库，从库只能实现非线性读。

**CAP理论(CP和AP理论😅)** 

C：一致性(可线性化)、A：可用性、P：分区容错性。

* 如果应用要求线性化，由于网络方面的问题，如果出现连接断开，整个服务将不可用。
* 如果不要求线性化，，连接断开之后，每个副本可以独立处理请求例如写操作(多主复制)。此时服务可用，但是不满足线性化。

虽然可线性化是一个很有用的保证，但实际上很少由系统真正满足可线性化，现代多核CPU上的内存甚至就是非线性化。







## 顺序保证

操作按照某种顺序执行。顺序执行有助于保持因果关系。如果系统服从因果关系所规定的顺序，我们称之为因果一致性。

[^]: 快照隔离提供了因果一致性：当从数据库中读取数据时，如果查询到了某些数据，也一定能看到该数据的前序条件。



可线性化是全序排列，而因果关系不是。==因果关系中可能会出现并发操作==，并发的操作之间是不能被排序的，而可线性化的顺序是严格确定的，==不能出现并发==。因此，可线性化一定意味着因果关系。因果关系至少可以定义为偏序，而非全序。

可线性化一定意味着因果关系，但线性化不是保证因果关系的唯一途径，在许多情况下，许多看似需要线性化的系统实际上真正需要的是因果一致性，后者的实现可以高效很多。

==维持因果关系==：为了保持因果关系，需要知道哪个操作发生在前，或许并发操作会以任意顺序执行，但<u>**如果一个操作发生在另一个操作之前，那么每个副本都应该按照相同的顺序处理**</u>。因此，每个副本在处理一个请求的时候，<u>**必须确保所有的因果在前的请求都完成处理**</u>。

确定请求的先后顺序需要跟踪整个数据库请求的因果关系，而不仅仅是针对某个主键。数据库需要知道应用程序读取的是哪个版本的数据。



### 跟踪因果关系的方案

**序列号排序**：跟踪所有的因果关系不切实际，因此可以使用序列号或者时间戳来对事件进行排序，时间戳可以只是一个逻辑时钟，比如递增的计数器。

如果系统不存在唯一的主节点，需要确保不同的节点永远不会生成相同的序列号。可以使用Lamport时间戳。每个节点有唯一的标识符，且每个节点都有一个计数器来记录各自已处理的请求总数。Lamport时间戳是一个值对(计数器→节点ID)，两个节点可能会有相同的计数器值，但==时间戳中还包含节点ID信息==，因此可以确保每个时间戳唯一。

Lamport时间戳可以保证全序：计数器大的时间戳大，计数器相同的，节点ID越大，时间戳越大。

[^]: 注：每次时间戳取的是所有节点中时间戳最大的然后+1，而不是当前节点。

Lamport时间戳还不足以解决实际分布式系统中许多常见的问题。如果需要选择时间戳较低的作为获胜者，收到请求的节点<u>需要检查其他节点的相同的请求的状态</u>，如果某个节点出现故障或者由于网络问题无法加载，那这种方法就无法运转。

为了实现这样的目标，仅仅对操作进行全序排列还是不够的，还需要知道这些操作是否发生、何时确定等。这就需要"全序关系广播"。



### 全序关系广播

在分布式系统中，让所有的节点就全序关系达成一致就面临巨大挑战。全序关系广播通常指节点之间交换消息的某种协议，要求满足两个基本安全属性：

* 可靠发送：没有消息丢失，如果消息发送到了某一个节点，则它一定要发送到所有节点。
* 严格有序：消息总是以相同的顺序发送给每个节点。

全序关系广播的另一个要点是==顺序在发送消息时已经确定==，如果消息发送成功，节点不允许追溯地将某条消息插入到先前地某个位置上。这一点使得全序关系广播比基于时间戳排序要求更强。

全序关系广播是基于异步模型：保证消息以固定地顺序可靠地发送，但是不保证消息何时发送成功；而可线性化则强调就近性。



虽然此过程可以确保线性化写入，但无法保证线性化读取，即从异步日志更新地存储中读取数据时，可能是旧值。具体来说，这里只提供了顺序一致性，也称为时间线一致性。为了同时满足线性化读取，有以下几个方案：

* 采用追加的方式把读请求操作排序、广播，然后各个节点获取该日志，当本节点收到消息时才执行真正地读操作。消息在日志中的==位置已经决定了读取发生地时间点==。
* 如果可以以线性化的方式获取当前最新日志中消息的位置，则查询位置，等待直到该位置之前的所有条目都已经发送给你，接下来再进行读取(sync)。
* 可以从同步更新的副本上进行读取，这样确保总是读取最新值，这种技术可以用于链式复制。



## 分布式事务与共识

共识问题：让几个节点就某件事情达成一致。

很多重要的场景都需要集群节点达成某种一致，例如主节点的选举(避免脑裂)和==原子事务的提交==(分布式事务)等。

### 原子提交与二阶段提交

在单节点上，事务提交非常依赖于数据持久化写入磁盘的顺序关系：先写入数据，然后再提交记录。事务提交的关键点在于磁盘完成日志记录的时刻(写完日志崩溃视为提交，否则回滚)。

如果一个事务涉及多个节点，必须确保所有的节点都成功提交，则需要使用2PC(二阶段提交)。

2PC在某些数据库内部使用，或者以XA事务形式提供给应用进程。<u>协调者发送准备请求到所有节点询问是否可以提交</u>，只有所有请求都回复是，才能进行提交，否则放弃。

==缺陷==：协调者在提交阶段崩溃会让参与者陷入无限等待的状态，如果部分参与者主动中止，会造成数据库状态的不一致。

2PC能够顺利完成的唯一方法是等待协调者恢复，这就要求协调者必须在`向参与者发送提交/中止请求之前`要将决定写入磁盘的事务日志，等协调者恢复后，通过读取事务日志来确定所有未决的事务状态。



### 实践中的分布式事务

分布式事务的某些实现存在严重的性能问题，2PC的性能下降的主要原因是为了防崩溃恢复而做的磁盘IO，以及额外的网络往返开销。

在事务执行的过程中会持有锁，因此如果协调者崩溃，这些数据对象将被锁定，如果协调者的日志由于某种原因而彻底丢失，这些数据对象将永久处于加锁状态。



从协调者故障中恢复：实际使用中，由于软件bug等导致日志损坏，最终协调者还是恢复失败，导致执行中的参与者无法自动解决，阻塞在那里，只能让管理员手动回滚。

许多XA的实现都支持某种紧急避险措施，称之为启发式决策：参与者节点可以在紧急情况下==单方面做出决定==，放弃或者继续那些停顿的事务(违背了原子性)。



**分布式事务的限制** 

XA事务解决了多个参与者之间如何达成一致这样一个现实而重要的问题，但它也引入了不少操作方面的限制。特别是，==协调者本身就是一种数据库==(存储事务的投票结果)，因此需要和其他重要的数据库一样格外小心。

* 如果协调者不支持数据复制，那么他就是整个系统的单点故障。
* 当协调者就是应用服务器的一部分时，应用服务器已经不再是无状态的。
* XA要求多系统兼容，因此它其实是多系统可兼容的最低标准，因此有些功能无法实现。
* 数据库内部的分布式事务(而不是XA)，限制则少很多，但是分布式事务还是很容易失败(一个节点失败则全失败)。





### 支持容错的共识

共识：让几个节点就某项提议达成一致。

共识问题通常形式化描述如下：一个或多个节点可以提议某些值，由共识算法来决定最终值。

> 比如，多人预约一个座位，处理顾客请求的每个节点可以提议他所服务的顾客ID，最后的决定则是关于由哪个顾客获得座位。

共识算法必须满足以下特性：

* 协商一致性：所有的节点都必须接受相同的决议。
* 诚实性：所有节点不能反悔，即对一项提议不能有两次决定。
* 合法性：如果决定了值v，则v一定是由某个节点所提议的。
* 可终止性：节点如果不崩溃则最终一定可以达成决议。

可终止性引入了容错的思想，它表示：即使某些节点出现了故障(独裁者或其他节点)，其他节点也必须最终做出决定。事实上，可以证明任何共识算法都需要==至少大部分==节点正确运行才能确保终止性，而这个多数就可以安全地构成quorum。



**共识算法与全序广播** 

最著名的共识算法包括VSR、Paxos、Raft、Zab。这些算法大部分并不是直接使用上述的形式化模型，而是决定了一系列值，然后采用==全序关系广播算法==。

全序关系广播相当于持续的多轮共识，每一轮共识的决定对应于一条消息：

* 由于协商一致性，所有节点决定以相同的顺序发送相同的消息。
* 由于诚实性，消息不能重复。
* 由于合法性，消息不会被破坏，也不是凭空捏造的。
* 由于可终止性，消息不会丢失。

一些数据库支持自动选举主节点和故障切换，通过选举把某个从节点提升为新的主节点，这样更接近容错式全序关系广播，从而达成共识。



**Epoch和Quorum** 

如果发现当前的主节点失效，节点就开始一轮投票选举新的主节点。选举会赋予一个单调递增的epoch号，如果出现了两个不同的主节点对应于不同的epoch号码，则具有更高epoch号码的主节点将获胜。

在主节点做出任何决定之前，他必须首先检查是否存在比它更高的epoch号码，否则就会产生冲突的决定。

它必须==从quorum节点中收集投票==。主节点如果想要做出某个决定，必须将提议发送给其他所有节点，等待quorum节点的响应。

投票通常分为两轮：先投票谁是主节点，再对主节点的提议进行投票。两轮投票之间的节点必须重叠，保证第二轮投票时当前主节点的地位没有变。



#### 共识的局限性

* 节点投票的过程是一个同步复制的过程。
* 共识体系需要严格的多数节点才能运行，因此至少需要三个节点才能容忍一个节点发生故障；如果由于网络故障切断了节点之间的连接，则只有多数节点所在的分区可以继续工作。
* 共识算法不能动态添加或者删除节点。
* 共识系统使用超时机制来检测节点失效，在分布式系统中由于网络延迟可能会发生误判。
* 共识算法往往对网络问题特别敏感。

