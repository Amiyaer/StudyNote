## 2 类加载子系统

![](pic\类加载器.png)

三个阶段：Loading(加载)、Linking(链接)、Initialization(初始化)。

==**总体作用**==：负责从文件系统或者网络中加载Class文件，class文件再文件开头有特定的文件标识。

只负责class文件的加载，是否可以进行由执行引擎决定。



### 2.1类加载过程

#### 2.1.1 Loading

1.通过一个类的全限定名获取定义此类的二进制字节流。

2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

3.**==在内存中生成一个代表这个类的java.lang.class对象(实例)==**，作为方法区这个类的各种数据路口。

加载方式有：从本地文件中直接加载、通过网络读取、从zip压缩包中读取、运行时计算生成、有其他文件生成、从专有数据库或加密文件中提取等。



#### 2.1.2 Linking

三个阶段

##### 1 验证(Verify)

字节码文件起始的内容是**CAFEBABE(也称为魔数)**，所有能被java虚拟机识别的字节码文件起始都是它。

验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身的安全。

##### 2 准备(Prepare)

为**类变量**(static)分配内存并设置该变量的默认初始值(零值)。

[^类变量]: 这里==不包含final关键字修饰的static==，因为final在编译的时候就会分配，这里会==显示==初始化。

==不会为实例变量分配初始化==，实例变量会随着对象一起分配到Java堆中。

##### 3 解析(Resolve)

将常量池内的符号引用转换为直接引用。

事实上，解析操作往往会伴随着JVM在执行完初始化后在执行。



#### 2.1.3 Initialization

类变量再上一个阶段具有零值，而会在这里初始化。

初始化阶段就是执行类构造器方法<clinit>()的过程。这个方法不需要定义，是javac编译器自动收集类中的所有==**类变量**的赋值动作==和==静态代码块==中的语句合并而来。

<clinit>()不同于类的构造器。构造器在虚拟机的视角下是<init>

如果当前类具有父类，JVM会保证字类的clinit执行之前，父类的clinit已经执行完毕。

虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁(一个类不能同时被多个线程加载)。





### 2.2 类加载器分类

JVM支持两种类型的类加载器，<u>引导类加载器</u>和<u>自定义类加载器</u>。

Java虚拟机将所有派生于抽象类ClassLoader的类加载器都划分为自定义加载器。

Java的核心类库都是使用引导类加载器进行加载的。

![](pic\类加载器的分类.png)



#### 2.2.1 系统自带加载器

1.启动类加载器(引导类加载器，Bootstrap ClassLoader)

==不能直接获取到==。

使用C/C++来编写，用来加载Java的核心类库。并不继承自java.lang.ClassLoader，即没有父加载器。

能够加载**扩展类**和**应用程序类加载器**，并指定它们的父类加载器。

2.扩展类加载器(Extension ClassLoader)

使用java编写。继承自ClassLoader类，父类加载器为启动类加载器。从**java.ext.dirs系统属性所指定的目录**中加载类库，或从jdk的安装目录的扩展目录下加载类库。用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。

3.应用程序类加载器(系统类加载器，AppClassLoader)

使用java编写。派生于ClassLoader类，父类加载器为扩展类加载器。负责加载**环境变量classpath或系统属性java.class.path指定路径下的类库**。

是程序的默认加载器，一般java应用的类都是由它进行加载。

4.用户自定义类加载器

为什么需要自定义类加载器：隔离加载类、修改类加载的方式、扩展加载源、防止源码泄露。

实现步骤：继承ClassLoader类并重写<u>loadClass()</u>`jdk1.2之前`方法或<u>findClass()</u>`jdk1.2之后`方法。如果没有特别复杂的需求，只需继承URLClassLoader类即可。



#### 2.2.2 关于ClassLoader

是一个抽象类，其后所有的类加载器都继承自ClassLoader(不包括启动类加载器)。

一些方法

| 方法名称                                          | 描述                                                         |
| ------------------------------------------------- | ------------------------------------------------------------ |
| getParent()                                       | 返回该类加载器的父类加载器                                   |
| loadClass(String name)                            | 加载名为name的类，返回结果为java.lang.Class的类的实例        |
| findClass(String name)                            | 查找名为name的类，返回结果为java.lang.Class的类的实例        |
| findLoadedClass(String name)                      | 查找名为name的已经被加载过的类，返回结果为java.lang.Class的类的实例 |
| defineClass(String name,byte[] b,int off,int len) | 把字节数组b中的内容转换为一个Java类，返回结果为java.lang.Class类的实例 |
| resolveClass(Class<?> c)                          | 连接指定的一个Java类                                         |

获取ClassLoader的途径

- 方式一:获取当前类的ClassLoader
  class.getClassLoader()
- 方式二:获取当前线程上下文的ClassLoader
  Thread.currentThread().getContextClassLoader()
- 方式三:获取系统的ClassLoader
  ClassLoader.getSystemClassLoader()
- 方式四:获取调用者的ClassLoader
  DriverManager.getCallerClassLoader()





### ==2.3 双亲委派机制==

Java虚拟机对class文件采用的是按需加载的方式，当需要使用该类时才会对它的class文件加载到内存生成class对象。

加载某个类的class文件，JVM采用的是双亲委派模式：把请求交由父类处理。它是一种任务委派模式。

工作原理：如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；父类加载器如果还有父类，**也向上委托**，直到顶层的启动类加载器。如果**父类加载器可以完成任务，就完成并直接返回**，否则就交给字类去完成。

```java
public class String{
    //核心API的String没有main方法，运行时会去找那个类的加载器。所以会报错：找不到java.lang.S
    static{
        System.out.println("我是自定义的String类的静态代码块");
    }
    public static void main(String[] args){
        System.out.println("hello,String");
    }
}
```



优势：避免类的重复加载，保护程序安全防止核心API被随意篡改。

<p style="background:aqua;">示例：在java.lang包下定义不重名的自己的类。运行这个类的main方法会报一个安全性问题的错，原因是管理该包的引导类加载器访问java.lang包是需要权限的。</p>



#### 2.3.1 沙箱安全机制

加载自定义的重名类的时候会率先使用引导类加载器进行加载，而引导类加载器在加载的过程中==会先加载jdk自带的文件==。这样可以保证对java核心源码的保护，这就是<span style="color:red">沙箱安全机制</span>。

> 比如自定义的String类，在加载过程中会先加载java.lang包下的String。





### 2.4 其他

1.在jvm中表示两个class对象是否为同一个类存在两个必要条件：完整类名是否一致、加载这个类的类加载器实例对象是否相同。

2.jvm必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的。如果是由用户类加载器加载的，那么jvm会<span style="color:red">将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</span>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。

3.Java程序对类的使用方式分为：主动使用和被动使用。

主动使用分为七种情况：

- 创建类的实例。
- 访问某个类或接口的静态变量，或者对该静态变量赋值。
- 调用类的静态方法。
- 反射(比如``Class.forName("com.atguigu.Test")``)。
- 初始化一个类的子类。
- Java虚拟机启动时被标明为启动类的类。
- java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化。

除此之外，其他使用Java类的方式都被看做是<span style="color:red">对类的被动使用</span>，<span style="color:red">不会导致类的初始化</span>。





































## 3 运行时数据区

完成类的加载后，在内存的方法区中保存类实例，此时就开始使用运行时数据区。整个执行引擎在执行的过程中，都需要使用到运行时数据区。

JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在部分差异。

运行时数据区包括方法区、程序计数器、本地方法栈、堆、虚拟机栈。

**==运行时数据区中的方法栈和堆是对应于进程(虚拟机)的(随着进程启动而创建，退出而销毁)，而程序计数器、本地方法栈、虚拟机栈是对应于线程的。==**



### 线程的说明

JVM允许一个应用有多个线程并发执行。在HotSpotJVM里，每个线程都与操作系统的本地线程直接映射。

一个Java线程准备好执行以后，一个操作系统的本地线程也同时创建。一旦本地线程初始化成功，就会调用Java线程中的run()方法。java线程执行终止后，本地线程也会回收。

一个Java程序也有很多的线程，这些线程在JVM里主要是：虚拟机线程、周期任务线程、GC线程、编译线程、信号调度线程。



### 程序计数器(PC寄存器)

命名源于CPU中的寄存器。是对物理PC寄存器的一种抽象模拟。

是很小的内存空间，几乎可以忽略不计，也是允许速度最快的存储区域。是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

==JVM中唯一一个没有GC和OOM的区域==。

任何时间一个线程只有一个方法执行，也就是所谓的==当前方法==。程序计数器会**存储当前线程正在执行的Java方法的JVM指令地址**；或者，如果是在执行native方法，则是未指定值(undefined)。

**作用**：用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。



示例：

![](pic\反编译.png)

![](pic\PC寄存器.png)

+++++

#### 两个常见问题

1.使用PC寄存器存储字节码指令地址有什么用(为什么使用PC寄存器记录当前线程的执行地址)？

答：因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行；JVM字节码解释器需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

2.PC寄存器为什么被设定为线程私有？

答：为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的方法就是为每一个线程都分配一个PC寄存器。<span style="color:red">如果不是线程私有就会出现相互干扰的情况(线程1的代码执行到x行但是线程2不是，切换到线程2的时候会从x开始执行，这样会造成干扰)</span>。

---





### 虚拟机栈

背景：由于跨平台的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计成基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。

在内存中，**栈是运行时的单位，而堆是存储的单位**。

Java虚拟机栈，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的**栈帧(Stack  Frame)**，对应着一次次的Java方法调用。

<span style="background:#33a3dc">一个栈帧对应着一次方法的调用。</span>

**Java虚拟机栈是线程私有的**，其生命周期和线程一致。主管Java程序的运行，保存方法的局部变量、部分结果，并参与方法的调用和返回。



特点：访问速度非常快；JVM对于栈的操作只有进栈和出栈，很便捷；不存在垃圾回收问题，但是存在OOM(OutOfMemory)的问题。



栈中可能出现的异常：

1.Java虚拟机规范允许Java栈的大小是动态或固定的。

- 如果是固定大小的栈，线程请求分配的栈容量**超过Java虚拟机允许的最大容量**，Java虚拟机就会抛出一个<u>StackOverflowError</u>异常。
- 如果是动态扩展的虚拟机栈，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时**没有足够的<span style="color:red">内存</span>**去创建对应的虚拟机栈，那Java虚拟机将会抛出一个<u>OutOfMemoryError</u>异常。



设置栈的大小

使用参数-Xss来设置线程的最大栈空间。

`-Xss大小`。

---





#### 栈的存储单位

每个线程都有自己的栈(不同线程中所包含的栈帧不允许相互引用)，而栈中的数据都是以==栈帧==的格式存在的。线程上正在**执行的每个方法都对应着一个栈帧**。

栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

一条活动线程在一个时间点上，只会有一个活动的栈帧。(只有当前正在执行的方法的栈帧<span style="font-size:9px">栈顶栈帧</span>是有效的，称为==**当前栈帧**==)对应的方法和类就是当前方法和当前类。

执行引擎运行的所有字节码指令只针对当前栈帧进行操作。



方法的结束方式：第一种是以return为代表；第二种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。不管是用哪种方式结束，都会导致栈帧被弹出，如果存在异常且没有被处理，该异常还会被抛给当前栈帧(方法)的调用者。



#### 栈帧的内部结构

每个栈帧中存储着五个部分：

- **<span style="color:red">局部变量表(Local  Variables)</span>**
- **<span style="color:red">操作数栈(Operand  Stack)(或表达式栈)</span>**
- 动态链接(Dynamic  Linking)(或指向运行时常量池的方法引用)
- 方法返回地址(return  address)(或方法正常退出或者异常退出的定义)
- 一些附加信息



##### 1.局部变量表

也称为局部变量数组或本地变量表。在栈帧中，与性能调优关系最密切的部分就是局部变量表。虚拟机使用局部变量表完成方法的传递。

<span style="background:#33a3dc">定义为一个==数字**数组**==，主要用于存储**方法参数**和定义在方法体内的**局部变量**以及方法的**返回值**。</span>这些变量的类型包括各种基本数据类型、对象引用，以及返回地址类型。

局部变量表建立在线程的栈上，是线程的私有数据，因此<u>不存在数据安全问题</u>。

==局部变量表所需的容量大小是在编译期就确定下来的==，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量的大小的。

<span style="color:red">局部变量表的变量也是重要的垃圾回收根节点，只要被局部变量表中直接引用或间接引用的对象都不会被回收。(啥时候这个指针不存在了，这个变量就会被垃圾回收)</span>。



###### 变量回顾

变量的分类：

​		按照数据类型分为：①基本数据类型  ②引用数据类型

​		按照在类中声明的位置分为：①成员变量：在使用前都经历过默认初始化赋值

​																			类变量：linking的prepare阶段：给类变量默认赋值   --->  initial阶段：给类变量显式赋值。

​																			实例变量：随着对象的创建会在对空间中分配实例变量空间，并进行默认赋值。

​		                                                  ②局部变量：在使用前必须要进行显式赋值，否则编译不通过。



###### jclasslib演示实例

方法如下：

```java
public static void testStatic(){
    LocalVariablesTest test = new LocalVariablesTest();
    Date date = new Date();
    int count = 10;
    System.out.println(count);
}
```

总体区域：方法大致介绍。

<init>：表示构造器。

<img src="pic\classlib1.png"/>

Code区域：方法的字节码指令。

- LineNumberTable：字节码行号与实际代码行号的对应关系

![](pic\classlib2.png)

- LocalVariableTable：局部变量表

![](pic\classlib3.png)





###### 关于Slot的理解

参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。

在局部变量表中<span style="color:red">最基本的存储单元是Slot(变量槽)</span>。



在局部变量表中，32位及以内的类型只占用一个slot(包括returnAddress类型)，**64位的类型(主要是long和double)占用两个slot**。

byte、short、char在存储前被转换为int，boolean也会被转化为int(0→F，1→T)。

**每个slot都会被分配一个访问索引**，通过这个索引可以访问局部变量表中的具体的局部变量值。访问64位的类型的槽时，访问的是起始的索引。其他方法在slot中的顺序就是代码中声明的顺序。



当前帧如果是由构造方法或者实例方法(非静态)，那么它们的内部会有一个`this`变量。这个this变量在slot中的索引index为0。其余的参数按照参数表的顺序继续排列。

![](E:\new add juan\学习\面试\pic\this.png)

==栈帧中的局部变量表中的槽位是可以重用的==，如果一个局部变量过了它的作用域，那么在其作用域之后申明的新的局部变量就有可能会复用过期局部变量的槽位，达到节省资源的目的。

---



##### 2.操作数栈(Operand Stack)

`JVM的解释引擎是基于栈的执行引擎`  其中的栈指的就是操作数栈。

每一个栈帧除了包含局部变量表，还包含一个后进先出的**操作数栈**，也可以称之为表达式栈。

操作数栈在方法执行的过程中，往栈中写入或者提取数据(入栈/出栈)。与一般的栈一样，操作数栈只能通过入栈出栈来进行数据访问，==不能通过索引==。

<div style="border:solid;border-width:1px;background:#F2F5A9">
    操作数栈，主要用于<span style="font-weight:bold">保存计算过程的中间结果</span>，同时作为计算过程中变量的临时的存储空间。被调用的方法如果有返回值，其返回值也会被压入当前栈帧的操作数栈中，同时更新PC寄存器中下一条需要执行的字节码指令。                     

与局部变量表一致，每一个操作数栈的长度(深度)在编译期就能确定好。`保存在方法的Code属性中，为max_stack的值`。

与局部变量表一致，32bit的类型占用一个栈深度，64bit的类型占用两个栈深度。



![](pic\return.png)



具体指令含义

`ipush`：操作数栈进栈

`iload`：操作数栈出栈

`istore`：局部变量表存入



栈顶缓存技术：操作数栈是存储在内存当中的，因此频繁的读写会影响执行速度。因此JVM设计者提出，将栈顶的元素全部缓存在物理CPU的寄存器中，用来降低对内存的读写次数，提升执行引擎的执行效率。

---





##### 3.动态链接

每一个栈帧内部都包含一个指向==**运行时常量池中**==该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现<u>动态链接</u>，比如invokedynamic指令。

0

