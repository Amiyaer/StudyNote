<img src="https://pic2.zhimg.com/80/v2-14e0536d872474b0851b62572b732e39_720w.jpg" alt="img" style="zoom:80%;" />







## 术语

* 文件描述符fd：一个用于表述指向文件的**引用**的抽象化概念。内核为每个进程维护了一个**该进程打开文件的记录表**。程序打开或创建一个新文件时，内核向进程返回一个文件描述符。

* 缓存IO：又被称为标准IO，大多数文件系统的默认IO操作都是缓存IO。在Linux的缓存IO机制中，**==数据会先被拷贝到操作系统内核的缓冲区中，然后才会从缓冲区拷贝到应用程序的地址空间==**。

* Linux IO模型：网络IO的本质是socket的读取。在Linux中，IO可以理解为对流的操作。
  * 一个read操作会经历两个阶段：
    * 等待数据准备。
    * 将数据从内核拷贝到进程中。
  * 对于相应的socket流而言：
    * **等待网络上的数据分组到达**，然后被复制到内核的某个缓冲区。
    * 把数据从内核缓冲区复制到应用进程缓冲区。







## 同步阻塞IO

最简单的模型，默认情况下所有的socket都是**阻塞状态**。用户空间的应用程序执行一个系统调用，导致应用程序阻塞，什么也不干，直到数据处理好，并且将数据从内核复制到用户进程，然后进程才处理数据。这个过程中，**整个进程都被阻塞，不能处理别的网络IO**。







## 同步非阻塞IO

使用一种轮询方式，"**每隔一会儿瞄一眼进度条**"。非阻塞IO也会进行recvform系统调用，检查数据是否准备好，如果没有准备好就会返回一个error。此时当前进程**可以干点别的事，过一段时间再发起系统调用**。这个过程被称为轮询。

轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。** `需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态`**。







## IO多路复用

一个进程循环查询多个任务的完成状态，**只要有任何任务完成，就去处理它**。此时轮询不是进程的用户态，而是有一个进程在做轮询工作。

基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。



### select

默认只能监视1024个socket。

一个进程同时监听多个socket，调用select之后，操作系统把进程分别加入到三个socket的等待队列中。

socket收到数据后，中断程序唤起进程，将其移除自己的等待队列。

进程遍历一遍socket列表，就知道哪些socket就绪。



### epoll

某个进程调用epoll的创建方法时，内核会创建一个eventpoll对象。这个对象是文件系统中的一员，同样有**等待队列**。

内核维护的"就绪列表"(表示哪个socket获得了数据输入)可以作为eventpoll的成员。



**监视列表**：创建出来的eventpoll对象需要监视socket是否接收了数据，**==内核会将eventpoll对象添加到socket的等待队列中==**。socket收到数据后，中断程序会**操作epoll对象**而不是直接操作进程。给epoll对象的"就绪列表"**添加相应的socket的引用**。

通过就绪队列，能知道哪些socket发生了变化。



**wait**：程序执行到epoll_wait的时候，只有就绪列表为空时，才阻塞进程。某个进程执行到epoll_wait的时候，内核会将它放入到eventpoll的等待队列中并阻塞进程。当socket接受到数据的时候，中断程序一边修改rdlist(就绪列表)，以便唤醒eventpoll等待队列中的进程。此时被唤醒的线程就能通过rdlist知道是哪个socket接收到了数据。



#### 就绪队列的数据结构

<img src="https://pic4.zhimg.com/80/v2-e63254878f67751dcc07a25b93f974bb_720w.jpg" alt="img" style="zoom: 80%;" />

eventpoll包含了lock、mtx、wq(等待队列)、rdlist等成员。rdlist和rbr是我们所关心的。

就绪列表的数据结构是双向链表，能够实现快速插入和删除。

索引结构rbr： epoll使用了红黑树作为索引结构（对应上图的rbr）。







## 异步非阻塞IO

异步IO不是顺序执行。用户进程进行`aio_read`系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户进程可以去做别的事情。等到socket数据准备好了，**内核直接复制数据给进程**。然后向进程发送通知。IO两个阶段，进程都是非阻塞的。









