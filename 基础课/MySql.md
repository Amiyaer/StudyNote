## MySQL的架构介绍

### 概述

mysql是一个关系型数据库管理系统，将数据保存在多个关联的表中而不是一个打的仓库。



高级MySQL：mysql内核、sql优化工程师、mysql服务器优化、各种参数常量设定、查询语句优化、主从复制、软硬件升级、容灾备份、sql编程。



### MYSQL的逻辑架构

从上到下

1.第一层是==连接层==，主要完成一些类似于链接处理、授权认证及相关的安全方案；

2.第二层是==业务逻辑处理层==，主要完成大多少的核心服务功能。所有跨存储引擎的功能也在这一层实现，如过程、函数等。服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。也能够把整条SQL进行备份等处理；

3.第三层是==数据存储引擎层==，真正负责了MySql中数据的存储和提取，服务器通过API与存储引擎进行通信。MYSQL支持多种数据库的存储引擎，目前最主流的是MyISAM和InnoDB；

4.最下面一层是==文件存储层==，主要是将数据存储在文件系统上，完成与数据引擎层的操作。



### MyISAM与InnoDB的区别

| 对比项   | MyISAM                                             | InnoDB                                                       |
| -------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 主外键   | 不支持                                             | 支持                                                         |
| 事务     | 不支持                                             | 支持                                                         |
| 行表锁   | 表锁，即使操作一条记录也会锁住整个表，不适合高并发 | 行锁，操作时只锁一行，不对其他行有影响。==适合高并发的操作== |
| 缓存     | 只缓存索引，不缓存真实数据                         | 缓存索引和真实数据，对内存的要求较高，而且内存大小对性能有决定性的影响 |
| 表空间   | 小                                                 | 大                                                           |
| 关注点   | 性能                                               | 事务                                                         |
| 默认安装 | Y                                                  | Y                                                            |

阿里巴巴大部分mql数据库其实使用的percona的原型加一修改

AliSql+AliRedis









## 索引的优化分析

### SQL性能下降的原因

性能下降SQL慢：执行时间长，等待时间长

- 查询语句写的烂(important)
- 索引失效(important)
- 查询关联太多join
- 服务器调优以及各个参数设置(缓冲、线程数等)



### 常见的join查询

#### SQL执行顺序

机读的顺序与手写的不同。机器==首先读取FROM==字段，根据FROM先找到具体的表；随后读取where、on、join等条件语句；最后才去读取SELECT、ORDER BY等查询语句。

![](E:\new add juan\学习\面试\pic\Mysql读取.png)

#### 七种JOIN

select  <select_list>  FROM  TableA  A  <join_method>  TableB  B  ON  A.Key=B.Key

- 内连接(INNER  JOIN)：结果仅保留两个表的公共部分。
- 左/右外连接(LEFT/RIGHT  JOIN)：结果保留==连接符左/右边==的那个表的全部。
- 左/右外连接+IS NULL：

```sql
#AB连接，且查询结果只属于A不属于B的情况如下：
SELECT <select_list>
FROM TableA A
RIGHT JOIN TableB B
ON A.key=B.key
WHERE B.Key IS NULL
```

- 全外连接FULL  OUTER  JOIN，取两个表属性上的并集。
- 全外连接+IS NULL：

```sql
#A，B全外连接，然后取得A和B的非公共部分。
SELECT <select_list>
FROM TableA A
FULL OUTER JOIN TableB B
ON A.key=B.key
WHERE A.key IS NULL 
OR B.Key IS NULL
```



由于MySQL不支持FULL字段，因此FULL全连接可以改写。

==某一边的外连接==与==另一边的外连接==的**合并再去重(union)**。

```sql
SELECT <select_list>
FROM TableA A
RIGHT JOIN TableB B
ON A.key=B.key
union  
SELECT <select_list>
FROM TableA A
left JOIN TableB B
ON A.key=B.key
```





### ==索引==

<u>索引index是帮助MySQL高效获取数据的==数据结构==。(索引是数据结构。)</u>

索引的目的在于提高查找效率，可以类比字典。

可以简单的理解为**排好序的快速查找数据结构**。



在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是索引。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在==磁盘==上。

<u>我们平常说的索引都是指==**B树**==结构组织的索引。其中聚焦索引、次要索引、复合索引、前缀索引、唯一索引默认都是使用==**B+**==树索引，统称索引。除了B+树这种索引外，还有**==哈希索引(hash index)==**等。</u>



#### 索引的优势和劣势

优势(排序和查找)：

1. 类似于大学图书馆建书目索引，<u>提高数据检索的效率</u>，降低数据库的**IO**成本。
2. 通过索引列对数据进行排序，<u>降低数据排序成本</u>，降低了**CPU**的消耗。

劣势：

1. 索引实际上也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也要占用空间。
2. 索引会降低更新表的速度，每次表进行了更新(INSERT、UPDATE、DELETE)之后，索引也要进行相对应的更新。
3. 索引只是提高效率的一个因素，如果MySQL有大数据量的表，就要花时间建立最优秀的索引(有时变更需要进行人为的处理)。



#### 索引的分类

1.单指索引：一个索引只包含单个列，一个表可以有多个单列索引。

2.唯一索引：索引列的值必须唯一，但允许有空值。

3.复合索引：一个索引包含了多个列。



#### 基本语法

```sql
#创建，两种方式，[]代表可以省略，其中columnname只有一个就是单指
CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));
ALTER mytable ADD [UNIQUE] INDEX [indexName] ON (columnname(length));
#删除
DROP INDEX[indexName] ON mytable;
#查看
SHOW INDEX FROM table_name/G

#四种方式来添加数据表的索引
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)
#该语句添加一个主键，这意味着索引值必须是唯一的，而且不能为null

ALTER TABLE tbl_name ADD UNIQUE index_name (column_list)
#这条语句创建索引的值必须是唯一的(除了NULL，NULL可能会出现多次)

ALTER TABLE tbl_name ADD INDEX index_name (column_list)
#添加普通索引值，索引值可以出现多次

ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)
#指定了索引为FULLTEXT，y
```



#### ==索引的结构==

![img](https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cuY29kaW5nbGFicy5vcmcvdXBsb2Fkcy9waWN0dXJlcy90aGVvcnktb2YtbXlzcWwtaW5kZXgvNC5wbmc?x-oss-process=image/format,png)

索引的结构是一颗B+树，**==真实的数据储存在叶子节点==**，每一层的块称为磁盘块。每一个磁盘块包含了几个数据项和指针(白色方块部分)。==*非叶子节点不存储真实的数据，只存储指引搜索方向的数据项*==。

数据项会指明所要查找的数据的范围(在哪个磁盘)。如果要查找某一个数据项，首先把最上层的磁盘块加载到内存，此时发生一次IO，在内存中用二分查找确定查找数据的范围。再去加载其他的磁盘，直到找到数据。

三层的B+树可以表示上百万的数据，如果上百万条数据只需要三次IO，查询性能提高会是巨大的。



**哪些情况适合建立索引**

- 主键自动建立唯一索引
- 频繁作为查询条件的字段
- 外键关系
- 查询中统计或者分组的字段

**哪些情况不适合建立索引**

- 表记录太小
- 数据重复且分布平均的表字段
- 频繁更新的字段不适合建立索引
- where条件用不到的字段不创建索引







### 性能分析和优化

Mysql中有专门负责优化select语句的优化器模块。它的主要功能是通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划。

MYSQL的三个常见瓶颈

- CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候。
- IO：磁盘IO瓶颈发生在装入数据远大于内存容量的时候。
- 服务器硬件的性能瓶颈：top，free，iostat和vmstat来查看系统的性能状态。



#### Explain

使用Explain关键字可以模拟优化器执行SQL查询语句，从而知道MYSQL是如何处理SQL语句的。

能干嘛：

- 表的读取数据
- 数据读取操作的操作类型
- 哪些索引可以使用
- 那些所以被实际使用
- 表之间的引用
- 每张表有多少行被优化器查询



使用：`Explain+SQL语句`。



##### ==执行计划包含的信息==

| id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
| ---- | ----------- | ----- | ---- | ------------- | ---- | ------- | ---- | ---- | ----- |

**1.id(表的读取顺序)**

select查询的序列号，包含一些数字，表示查询中执行的select子句或操作表的顺序。

id相同，执行顺序由上到下(顺序执行)。

id不同，id值越大优先级越高。如果是子查询，id的值越大越先被执行。

(不同大的先行，相同顺序执行)

**2.select_type(数据读取操作的操作类型)**

查询的**类型**，主要是用于区别查询(普通查询or复杂查询)。

| SIMPLE       | 简单的select查询，查询中不包含子查询或者UNION                |
| ------------ | ------------------------------------------------------------ |
| PRIMARY      | 查询中包含任何复杂的子部分，最外层查询被标记为PRIMARY(最后加载的鸡蛋壳) |
| SUBQUERY     | 表示**在SELECT或WHERE列表中的子查询**                        |
| DERIVED      | **在from列表中包含的子查询**，MYSQL会递归这些查询，把结果放在临时表里 |
| UNION        | **SELECT语句中的UNION后的SELECT查询**。如果UNION包含在子查询，外层SELECT会被标记为DERIVED |
| UNION RESULT | **从UNION表获取结果的SELECT**。                              |

3.table

显示这一行数据是关于哪张表的。

==**4.type**==

访问类型。

显示查询使用了何种类型，从最好到最差依次是：==system>const>eq_ref>ref>range>index>ALL==。

一般来说要保证达到range和ref级别。

| system | 表中只有一行记录，是const类型的特例，可以忽略不计(没什么用)  |
| ------ | ------------------------------------------------------------ |
| const  | 表示通过索引一次就找到了，只有一个数据能匹配，所以很快。用于比较==primary key==或者==unique==索引。 |
| eq_ref | 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。`用了索引只查到一条数据`。 |
| ref    | 非唯一性索引扫描，返回匹配某一个单指的所有行，可能会找到多个符合条件的行也可能是一行。 |
| range  | 只检索==给定范围==的行，使用一个索引来选择行。一般就是在where语句中出现了between、<、>、in等的查询。这种扫描比全体扫描要好。 |
| index  | 读取全表，但是只遍历索引树。比如select特定的字段，而这个字段就是索引中的字段。 |
| ALL    | 全表扫描，遍历全表以找到匹配的行。                           |

5.possible_keys和key

possible_keys：可能应用在表中的索引，可能会有多个。列出的索引不一定会被实际使用。

key：实际使用的索引。如果为NULL，则没有使用索引。

查询中若使用了覆盖索引，则该索引仅出现在key列表之中。

[^覆盖索引]: 查询的字段刚好与建立的索引的个数和顺序刚好一致。

6.key_len

key_len显示的值为索引字段的最大可能长度，而并非真实长度。该值是根据表定义的计算得到的，而不是通过表内检索出的。

索引的长度指索引中使用的字节数。在不损失精确性的前提下，索引长度越短越好。

查询条件的增加会导致索引可能长度的增加(精度增加了)。

==**7.ref**==

显示索引的哪一列被使用了(用什么来检索索引)，如果可能的话，是一个常数(const)。

![](E:\new add juan\学习\面试\pic\索引.png)

在上图的查询语句中，t1引用了t2的col1列和一个常量，而t2没有引用任何，因此t1有ref而t2没有。



##  查询截取分析







## MySql锁机制







## 主从复制