## 1 MySQL的架构介绍

### 概述

mysql是一个关系型数据库管理系统，将数据保存在多个关联的表中而不是一个打的仓库。



高级MySQL：mysql内核、sql优化工程师、mysql服务器优化、各种参数常量设定、查询语句优化、主从复制、软硬件升级、容灾备份、sql编程。



### MYSQL的逻辑架构

从上到下

1.第一层是==连接层==，主要完成一些类似于链接处理、授权认证及相关的安全方案；

2.第二层是==业务逻辑处理层==，主要完成大多少的核心服务功能。所有跨存储引擎的功能也在这一层实现，如过程、函数等。服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。也能够把整条SQL进行备份等处理；

3.第三层是==数据存储引擎层==，真正负责了MySql中数据的存储和提取，服务器通过API与存储引擎进行通信。MYSQL支持多种数据库的存储引擎，目前最主流的是MyISAM和InnoDB；

4.最下面一层是==文件存储层==，主要是将数据存储在文件系统上，完成与数据引擎层的操作。



### MyISAM与InnoDB的区别

| 对比项   | MyISAM                                             | InnoDB                                                       |
| -------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 主外键   | 不支持                                             | 支持                                                         |
| 事务     | 不支持                                             | 支持                                                         |
| 行表锁   | 表锁，即使操作一条记录也会锁住整个表，不适合高并发 | 行锁，操作时只锁一行，不对其他行有影响。==适合高并发的操作== |
| 缓存     | 只缓存索引，不缓存真实数据                         | 缓存索引和真实数据，对内存的要求较高，而且内存大小对性能有决定性的影响 |
| 表空间   | 小                                                 | 大                                                           |
| 关注点   | 性能                                               | 事务                                                         |
| 默认安装 | Y                                                  | Y                                                            |

阿里巴巴大部分mql数据库其实使用的percona的原型加一修改

AliSql+AliRedis









## 2 索引的优化分析

### SQL性能下降的原因

性能下降SQL慢：执行时间长，等待时间长

- 查询语句写的烂(important)
- 索引失效(important)
- 查询关联太多join
- 服务器调优以及各个参数设置(缓冲、线程数等)



### 常见的join查询

#### SQL执行顺序

机读的顺序与手写的不同。机器==首先读取FROM==字段，根据FROM先找到具体的表；随后读取where、on、join等条件语句；最后才去读取SELECT、ORDER BY等查询语句。

![](E:\new add juan\学习\面试\pic\Mysql读取.png)

#### 七种JOIN

select  <select_list>  FROM  TableA  A  <join_method>  TableB  B  ON  A.Key=B.Key

- 内连接(INNER  JOIN)：结果仅保留两个表的公共部分。
- 左/右外连接(LEFT/RIGHT  JOIN)：结果保留==连接符左/右边==的那个表的全部。
- 左/右外连接+IS NULL：

```sql
#AB连接，且查询结果只属于A不属于B的情况如下：
SELECT <select_list>
FROM TableA A
RIGHT JOIN TableB B
ON A.key=B.key
WHERE B.Key IS NULL
```

- 全外连接FULL  OUTER  JOIN，取两个表属性上的并集。
- 全外连接+IS NULL：

```sql
#A，B全外连接，然后取得A和B的非公共部分。
SELECT <select_list>
FROM TableA A
FULL OUTER JOIN TableB B
ON A.key=B.key
WHERE A.key IS NULL 
OR B.Key IS NULL
```



由于MySQL不支持FULL字段，因此FULL全连接可以改写。

==某一边的外连接==与==另一边的外连接==的**合并再去重(union)**。

```sql
SELECT <select_list>
FROM TableA A
RIGHT JOIN TableB B
ON A.key=B.key
union  
SELECT <select_list>
FROM TableA A
left JOIN TableB B
ON A.key=B.key
```





### ==索引==

<u>索引index是帮助MySQL高效获取数据的==数据结构==。(索引是数据结构。)</u>

索引的目的在于提高查找效率，可以类比字典。

可以简单的理解为**==排好序==的快速查找数据结构**。



在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是索引。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在==磁盘==上。

<u>我们平常说的索引都是指==**B树**==结构组织的索引。其中聚焦索引、次要索引、复合索引、前缀索引、唯一索引默认都是使用==**B+**==树索引，统称索引。除了B+树这种索引外，还有**==哈希索引(hash index)==**等。</u>



#### ==索引的数据结构==

![？](..\pic\索引的实现原理.png)

- 二叉树(早期，不适合单边增长的情况)
- 红黑树(树太高了)
- Hash表
- B-Tree
- B+树√

![](..\pic\B+.png)

查找30：整个查找过程使用二分查找。首先把根节点整个读取到内存RAM中(做一次IO)，在内存中进行比对；比对后会找到一个子节点的地址，继续把下一个子节点读取到RAM中查找；直到找到确定的数据，返回查找的地址，从磁盘中根据地址直接获取。

#### 索引的优势和劣势

优势(排序和查找)：

1. 类似于大学图书馆建书目索引，<u>提高数据检索的效率</u>，降低数据库的**IO**成本。
2. 通过索引列对数据进行排序，<u>降低数据排序成本</u>，降低了**CPU**的消耗。

劣势：

1. 索引实际上也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也要占用空间。
2. 索引会降低更新表的速度，每次表进行了更新(INSERT、UPDATE、DELETE)之后，索引也要进行相对应的更新。
3. 索引只是提高效率的一个因素，如果MySQL有大数据量的表，就要花时间建立最优秀的索引(有时变更需要进行人为的处理)。



#### 索引的分类

1.单指索引：一个索引只包含单个列，一个表可以有多个单列索引。

2.唯一索引：索引列的值必须唯一，但允许有空值。

3.复合索引：一个索引包含了多个列。



#### 基本语法

```sql
#创建，两种方式，[]代表可以省略，其中columnname只有一个就是单指
CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));
ALTER mytable ADD [UNIQUE] INDEX [indexName] ON (columnname(length));
#删除
DROP INDEX[indexName] ON mytable;
#查看
SHOW INDEX FROM table_name/G

#四种方式来添加数据表的索引
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)
#该语句添加一个主键，这意味着索引值必须是唯一的，而且不能为null

ALTER TABLE tbl_name ADD UNIQUE index_name (column_list)
#这条语句创建索引的值必须是唯一的(除了NULL，NULL可能会出现多次)

ALTER TABLE tbl_name ADD INDEX index_name (column_list)
#添加普通索引值，索引值可以出现多次

ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)
#指定了索引为FULLTEXT，y
```



#### ==索引的结构==

![img](https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cuY29kaW5nbGFicy5vcmcvdXBsb2Fkcy9waWN0dXJlcy90aGVvcnktb2YtbXlzcWwtaW5kZXgvNC5wbmc?x-oss-process=image/format,png)

索引的结构是一颗B+树，**==真实的数据储存在叶子节点==**，每一层的块称为磁盘块。每一个磁盘块包含了几个数据项和指针(白色方块部分)。==*非叶子节点不存储真实的数据，只存储指引搜索方向的数据项*==。

数据项会指明所要查找的数据的范围(在哪个磁盘)。如果要查找某一个数据项，首先把最上层的磁盘块加载到内存，此时发生一次IO，在内存中用二分查找确定查找数据的范围。再去加载其他的磁盘，直到找到数据。

三层的B+树可以表示上百万的数据，如果上百万条数据只需要三次IO，查询性能提高会是巨大的。



**哪些情况适合建立索引**

- 主键自动建立唯一索引
- 频繁作为查询条件的字段
- 外键关系
- 查询中统计或者分组的字段

**哪些情况不适合建立索引**

- 表记录太小
- 数据重复且分布平均的表字段
- 频繁更新的字段不适合建立索引
- where条件用不到的字段不创建索引







### 性能分析和优化

Mysql中有专门负责优化select语句的优化器模块。它的主要功能是通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划。

MYSQL的三个常见瓶颈

- CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候。
- IO：磁盘IO瓶颈发生在装入数据远大于内存容量的时候。
- 服务器硬件的性能瓶颈：top，free，iostat和vmstat来查看系统的性能状态。



#### Explain

使用Explain关键字可以模拟优化器执行SQL查询语句，从而知道MYSQL是如何处理SQL语句的。

能干嘛：

- 表的读取数据
- 数据读取操作的操作类型
- 哪些索引可以使用
- 那些所以被实际使用
- 表之间的引用
- 每张表有多少行被优化器查询



使用：`Explain+SQL语句`。



##### ==执行计划包含的信息==

| id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
| ---- | ----------- | ----- | ---- | ------------- | ---- | ------- | ---- | ---- | ----- |

**1.id(表的读取顺序)**

select查询的序列号，包含一些数字，表示查询中执行的select子句或操作表的顺序。

id相同，执行顺序由上到下(顺序执行)。

id不同，id值越大优先级越高。如果是子查询，id的值越大越先被执行。

(不同大的先行，相同顺序执行)

**2.select_type(数据读取操作的操作类型)**

查询的**类型**，主要是用于区别查询(普通查询or复杂查询)。

| SIMPLE       | 简单的select查询，查询中不包含子查询或者UNION                |
| ------------ | ------------------------------------------------------------ |
| PRIMARY      | 查询中包含任何复杂的子部分，最外层查询被标记为PRIMARY(最后加载的鸡蛋壳) |
| SUBQUERY     | 表示**在SELECT或WHERE列表中的子查询**                        |
| DERIVED      | **在from列表中包含的子查询**，MYSQL会递归这些查询，把结果放在临时表里 |
| UNION        | **SELECT语句中的UNION后的SELECT查询**。如果UNION包含在子查询，外层SELECT会被标记为DERIVED |
| UNION RESULT | **从UNION表获取结果的SELECT**。                              |

3.table

显示这一行数据是关于哪张表的。

==**4.type**==

访问类型。

显示查询使用了何种类型，从最好到最差依次是：==system>const>eq_ref>ref>range>index>ALL==。

一般来说要保证达到range和ref级别。

| system | 表中只有一行记录，是const类型的特例，可以忽略不计(没什么用)  |
| ------ | ------------------------------------------------------------ |
| const  | 表示通过索引一次就找到了，只有一个数据能匹配，所以很快。用于比较==primary key==或者==unique==索引。 |
| eq_ref | 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。`用了索引只查到一条数据`。 |
| ref    | 非唯一性索引扫描，返回匹配某一个单指的所有行，可能会找到多个符合条件的行也可能是一行。 |
| range  | 只检索==给定范围==的行，使用一个索引来选择行。一般就是在where语句中出现了between、<、>、in等的查询。这种扫描比全体扫描要好。 |
| index  | 读取全表，但是只遍历索引树。比如select特定的字段，而这个字段就是索引中的字段。 |
| ALL    | 全表扫描，遍历全表以找到匹配的行。                           |

5.possible_keys和key

possible_keys：可能应用在表中的索引，可能会有多个。列出的索引不一定会被实际使用。

key：实际使用的索引。如果为NULL，则没有使用索引。

查询中若使用了覆盖索引，则该索引仅出现在key列表之中。

[^覆盖索引]: ==select的数据列只用从索引中就能取得==。如果要使用覆盖索引，不可select *。

6.key_len

key_len显示的值为索引字段的最大可能长度，而并非真实长度。该值是根据表定义的计算得到的，而不是通过表内检索出的。

索引的长度指索引中使用的字节数。在不损失精确性的前提下，索引长度越短越好。

查询条件的增加会导致索引可能长度的增加(精度增加了)。

==**7.ref**==

显示索引的哪一列被使用了(**用什么来检索索引**)，如果可能的话，是一个常数(const)。Type表示索引类别，ref决定性能。

<img src="..\pic\索引.png" style="zoom:120%;" />

在上图的查询语句中，t1引用了t2的col1列和一个常量，而t2没有引用任何，因此t1有ref而t2没有。

8.rows

根据索引的使用情况，大致估算出找到所需的记录所需要读取的行数。

9.extra

不适合在其他列中显示 但是十分重要的额外信息。

- ==using  filesort==：使用文件排序。说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取(最左原则)。(出现这种情况十分危险)。

[^explain]: 使用ORDER BY的时候如果order的字段是在索引中的字段且(==串顺序||少字段==)，就会出现该信息。正常的顺序若索引的第一个字段使用了in匹配，同样会出现此信息提示，不含in的字段还会出现using temporary。

- ==using temporary==：表明使用了临时表保存中间结果。mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by，或in等。(这种情况更为严重，查询速度会被严重拖慢)。

- ==using index==：表示select操作中使用了覆盖索引，避免了访问表的数据行，效率不错。

[^explain]: 如果没有出现using where，表明索引被用来执行索引键值的查找(查询条件)；如果没有出现，则说明索引用来读取数据而非执行查找操作。

- using where：表明使用了where查询条件。

- using join buffer：使用了连接缓存。

- impossible where：where 子句的值总是false。

- ~~select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段在进行计算，查询执行计划生成的阶段即完成优化。~~

- distinct：优化distinct操作，再找到第一匹配的元组后即停止找同样值的动作。

---

#### 索引优化

范围(>、<、in等)后的索引会失效。

##### 单表案例

查询category_id为1且comments大于1的情况下，view最多的article_id

```sql
#第一次尝试使用三个字段来建立索引
create index idx_article_ccv on article(category_id,comments,view)

explain select id,author_id FROM article where category_id=1 and comments>1 order by views DESC limit 1
```

![](..\pic\case1.1.png)

```sql
#但是结果出现了文件排序，这是由于第二个字段comments是一个范围，使得索引失效了。
#改进：不使用comments作为字段建立索引，而使用其他两个字段作为索引
create index idx_article_cv on article(category_id,view)
```

![](..\pic\case1.2.png)



##### 两表案例(含有主外键的情况)

```sql
#两表的左外连接
explain select * from class LEFT JOIN book ON class.card=book.card;

#1.加索引给左连接的右边的外键，右表的查询得到改善
#2.加索引给左连接的左边的外键，左表的查询也得到改善，但改善幅度小得多
```

结论：左连接的情况，左边的数据一定全部都有。所以右边是关键点，必须建立索引。右连接的情况，左边是关键点，必须建立索引。



##### 三表案例

```sql
SELECT * from class LEFT JOIN book ON class.card=book.card LEFT JOIN phone ON book.card=phone.card;

#现在，在book表和phone表中分别建一个索引(card字段)，再进行查询，结果这两个字段的type都是ref且总的rows优化很好。
```

索引最好设置在需要经常查询的字段中。

![](..\pic\case3.png)



**结论：尽可能用小结果驱动大的结果；优先优化NestedLoop的内层循环；==保证Join语句中<u>被驱动表</u>上Join条件字段已经被索引==；无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝啬JoinBuffer的设置。**





##### 索引失效：建立的索引顺序在查询中没有被使用

原因：

1.全值匹配

​		全值匹配(==**WHERE**==)不能违背最佳左前缀法则，否则就会失效。(带头大哥不能缺少，中间兄弟不能断)。缺少"大哥"全部失效，缺少中间部分失效。

[^最佳左前缀法则]: 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前缀开始并且不跳过索引中的列。

2.在索引列上做**任何操作**，会导致索引失效转向全表扫描。

​		所谓的操作包含计算、函数、**自动**或手动的类型转换。

3.存储引擎不能使用索引中**范围条件**右边的列。

==范围(range、>、<)以后全失效==。范围前的where字段主要用于检索(查找)，而范围着重用于**==排序==**，like的右百分号情况不包含在内。

4.尽量使用覆盖索引(减少select *)

​		使用覆盖索引使得`范围后全失效`中的例子的type从range变成了ref，速度明显提升。

​		使用(<u>*索引外字段只有主键的字段*</u>)不会使得索引失效，主键默认有一个主键索引。

![](..\pic\优化4.png)

5.使用==不等于(!=或<>)==的时候无法使用索引会导致**全表扫描**。

6.is null和is not null无法使用索引。

**7.==like==以通配符开头('%abc...')索引会失效会变成全表扫描的操作。**

![](..\pic\like失效.png)

​		写like查询的时候最好**只**在右边写百分号，如果在左边出现了百分号，就会使得索引失效。

​		解决like  '%字符串%'时索引不被使用的方法：使用**覆盖索引**。

8.字符串**不加单引号**会导致索引失效

​		如2000整数和varchar，如果字段是varchar类型，而传进来的是整数，MySQL会在底层==做一次类型转换==，同时使得索引失效。

9.少用**or**，用它来连接时会使得索引失效。

----

#### 面试题分析

1.where中的字段都是索引的字段且都是"="的情况下，即使交换顺序也不会使得索引失效，因为MySQL中的优化器对查询语句进行了优化，**会把它们的顺序按照索引的顺序排好序**。在写的过程中最好还是要按照索引的顺序来写确保万无一失。

2.where中在优化的情况下，依然遵循范围之后全失效(**排好序的情况下**)。

3.按照索引的顺序，用来**排序(order by)**的字段之后的字段有没有与结果没有关系(排序字段后的字段不会作为索引被使用)。

4.排序的字段的顺序是不会被MySQL优化的。

5.查找和排序 的索引字段是可以在边界重复的(1、2查找，2、3排序，索引不会失效，也不会使用filesort)。==**在这种情况下，边界字段在排序中的顺序可以随机(2、3=3、2)，因为排序字段2已经确定**==。

6.与排序字段相比，分组字段(group by)若顺序不对，不仅会产生filesort，还会产生using temporary。后果特别严重。group by表面上是分组，但是<u>***分组之前必排序***</u>，所以它的规则与排序类似。

---





##  3 查询截取分析

### 3.1 分析

1.观察。至少跑一天，看看慢SQL情况。

2.开启慢查询日志，设置阈值(比如超过5秒钟的就是慢SQL)并将他抓取出来。

3.explain+慢SQL分析(80%)

4.show profile(99%)

5.运维经理或DBA，进行数据库服务器的参数调优。



### 3.2 查询优化

永远小表驱动大表(小的数据集驱动大的数据集)：如果使用大表驱动小表，那么就需要很多次的连接建立与连接始放。如果是小表驱动大表，连接建立的次数会变少。

```sql
select * from t1 where col1 in (select col1 from t2)
#1.当括号中的表较小时，使用in，此时就是小表驱动大表.
#2.当括号中的表比括号外的表大的时候，如果依然使用in，情况是大表驱动小表，此时需要把in改写成exit，变回小表驱动大表。
select * from t1 where exists (select 1 from t2 where t2.col1 = t1.col1)
```



#### 3.2.1 EXISTS

`SELECT ...... FROM table WHERE EXISTS (subquery)`

改语法可以理解为：**将主查询的数据，放到子查询中做条件验证，根据验证结果(True 或 FALSE)** 来决定主查询的数据结果是否得以保留。

==**EXISTS(子查询)只返回True或False**==，因此子查询中select的字段可以是一个数字甚至一个字母。子查询往往也可以用条件表达式、其他子查询或者JOIN替代。

---



#### 3.2.2 Order By 关键字优化

order by中的字段如果**不全是ASC升序或DES降序**，就会出现filesort字段。(索引中的顺序默认全是升序，如果order by中出现了部分降序，就没有使用索引的顺序，也会出现filesort)。

MySQL支持FileSort和Index两种排序方式，Index效率高，它指MySQL扫描索引本身完成排序。



ORDER BY满足两情况，会使用Index方式排序：

1.ORDER BY语句使用满足最佳左前缀原则。

2.使用Where子句与Order By子句条件列**组合满足**索引最左前缀原则。

如果不在索引列上，filesort有两种算法：

- 单路排序：4.1之后的算法。它的效率要快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是会使用更多空间，因为它把每一行都保存在内存中了。
  - 从磁盘读取查询需要的所有列，按照order by列在buffer对他们进行了排序，然后扫描排序后的列表进行输出。
- 双路排序：MySQL4.1之前使用双路排序，字面意思就是两次扫描磁盘，最终得到数据。
  - 1.读取指针列和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据，输出。
  - 2.从磁盘读取排序字段，在buffer进行排序，再从磁盘读取其他字段。



单路总体好过双路，但是使用单路存在一定的问题：*<u>排序的buffer(sort_buffer)中，单路排序需要更多的空间，**因为是把所有字段都取出**，每次只能取sort_buffer容量大小的数据进行排序(会创建临时表，之后再合并)。这样反而会造成多次IO，得不偿失</u>*。

单路优化策略：

1. 避免使用select *，字段过多容易把sort_buffer占满。
2. 增大sort_buffer_size参数的设置。
3. 增大max_length_for_sort_data参数的设置。



#### ~~*3.2.3 group by关键字优化~~

实质是先排序后分组，与order by基本一致。同样遵循最佳左前缀。

优化方案同order by，尽量少用having，能用where解决的就不要用having解决。

---



### 3.3 慢查询日志

MySQL提供的一种日志记录，默认是不开启的，不调优建议不开启。它用来记录在MySQL中响应时间超过阈值的语句，具体是指运行时间超过long_query_time值（默认为10）的SQL，会被记录到慢查询日志中。

```sql
#查看
SHOW VARIABLES LIKE '%slow_query_log%'
#开启(只对当前数据库生效)
set global slow_query_log=1
#永久生效：修改配置文件my.cnf

#查看阙值
SHOW VARIABLES LIKE '%long_query_time%'
#设置时间(需要重新连接才能看到修改后的值)
set global long_query_time=3

#查看慢SQL语句:mysql/当前数据库文件-slow.log

#查询有多少条慢SQL记录
show global status like '%Slow_queries%'
```



日志分析工具：mysqldumpslow  --help

操作：mysqldumpslow  -[OPTS..参数]  [LOGS..日志]

----





### 3.4 Show Profile分析

MySQL提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量。

默认情况下关闭，开启后保存最近15次运行结果。

```SQL
#查看当前profile状态
show variables like 'profiling'
#开启
set profiling=on

#查看执行过的SQL
show profiles

#诊断SQL
show profile [cpu],[block io] for query [SQL的Query_ID]
```

诊断SQL可用的参数：

| 参数              | 含义                                                         |
| ----------------- | ------------------------------------------------------------ |
| ALL               | 显示所有开销信息                                             |
| BLOCK  IO         | 显示块IO相关开销                                             |
| CONTEXT  SWITCHES | 上下文切换相关开销                                           |
| CPU               | 显示CPU相关开销信息                                          |
| IPC               | 显示发送和接收相关开销信息                                   |
| MEMORY            | 显示内存相关开销信息                                         |
| PAGE  FAULTS      | 显示页面错误相关开销信息                                     |
| SOURCE            | 显示和Source_function，Source_file，Source_line相关的开销信息 |
| SWAPS             | 显示交换次数相关开销的信息                                   |

![](..\pic\profile.png)

上图显示了查询语句完整的生命周期和过程、分解步骤等。



**一些提示信息**

**converting HEAP to MyISAM**：查询结果太大，内存都不够用了往磁盘上搬了。

**Creating tmp table**：创建临时表，拷贝数据到临时表，用完再删除。

**Copying to tmp table on disk**：把内存中的临时表复制到了磁盘，==危险！==。

**locked**：数据被🔒了。

---



### 3.5 全局查询日志

不要在生产环境中开启这个功能

```sql
#开启
set global general_log=1
#以表的形式展示
set global log_output='TABLE'
```

运行上述两个命令之后，编写的sql语句将会记录到mysql库里的general_log表

```sql
#查看
select * from mysql.general_l
```

---





















## 4 MySQL锁机制

计算机中协调多个进程或线程并发访问某一资源的机制。

分类：数据操作的类型分为读锁和写锁，对数据操作的粒度来看分为行锁和表锁。

---

### 4.0 事务

由一组SQL语句组成的逻辑处理单元。

事务具有以下4个属性，通常简称为事务的ACID属性。

1. 原子性(**A**tomicity) :事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
2. 一致性(**C**onsistent) :在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性:事务结束时，所有的内部数据结构(如B树索引或双向链表)也都必须是正确的。
3. 隔高性(**I**solation) :数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
4. 持久性(**D**urable) :事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。



#### 4.0.1 ==并发==事务带来的问题

更新丢失(Lost Update)：两个或多个事务选择了同一行导致，每个事务都不知道其他事务的存在。==**最后的更新覆盖了由其他事务所做的更新**==。

脏读(Dirty Reads)：一个事务读取到了另一个事务**已修改但尚未提交**的数据。

不可重复读(Non-Repeatable Reads)：一个事务读取以前读过的数据，却发现这个数据已经发生了改变(其他事务的提交)，不符合隔离性。

幻读(Phantom Reads)：一个事务按照相同的查询条件读取以前检索过的数据，却发现**==其他事务插入了满足查询条件的新事物==**，不符合隔离性。



#### 4.0.2 事务隔离级别

| 读数据一致性及允许的并发副作用隔离级别 | 读数据一致性                             | 脏读 | 不可重复度 | 幻读 |
| -------------------------------------- | ---------------------------------------- | ---- | ---------- | ---- |
| 未提交读R u                            | 最低级别，只能保证不读取物理上损坏的数据 | 是   | 是         | 是   |
| 已提交读R c                            | 语句级                                   | 否   | 是         | 是   |
| 可重复读R r==(MySQL默认)==             | 事务级                                   | 否   | 否         | 是   |
| 可序列化S                              | 最高级别，事务级                         | 否   | 否         | 否   |

查看当前数据库的事务隔离级别：`show variables like 'tx_isolation'`。

---

### 4.1 读锁

针对同一份数据，多个读操作可以同时进行而不会相互影响。

### 4.2 写锁

当前写操作没有完成前，它会阻断其他写锁和读锁。

---

### 4.3 行锁(偏写)

偏向于InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

InnoDB与MyISAM的最大不同有两点：支持事务；采用了行级锁。

- 多个会话(线程)对**同一行数据**进行修改时，先修改的会话必须要**commit**，后面的会话才能继续修改，否则就会阻塞。同时，只有commit后其他session才能读取到修改后的数据。
- 多个会话(线程)对**不同行数据**进行修改时，互不影响，都不阻塞。



#### 4.3.1 索引失效使得行锁变表锁

只要索引失效，行锁直接变成表锁。即使修改不同行，后者也会阻塞。



#### 4.3.2 间隙锁的危害

间隙锁：Query通过范围查找时，行锁会锁定这个范围内的所有行(**==即使这个行不存在==**)

对于**==在范围内但是不存在的数据==**，叫做"间隙GAP"。对这个间隙的锁就是间隙锁。

危害：在锁定的时候**无法插入锁定键值范围内的任何数据**。



4.3.3 如何给一个数据上锁

`select * from table where(balabala) for update`

4.3.4 如何分析行锁定

检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况

```sql
show status like 'innodb_row_lock%'

#各个状态量的说明
#Innodb_row_lock_current_waits: 当前正在等待锁定的数量:
#Innodb_row_lock_time: 从系统启动到现在锁定总时间长度;
#Innodb_row_lock_time_avg: 每次等待所花平均时间:
#Innodb_row_lock_ftime_max:从系统启动到现在等待最常的一次所花的时间;
#Innodb_row_lock_waits: 系统启动后到现在总共等待的次数:
#对于这5个状态变量，比较重要的主要是
Innodb_row_lock_time_avg (等待平均时长)，
Innodb_row_lock_waits (等待总次数)
Innodb_row_lock_time (等待总时长)这三项。
#尤其是等待次数很高，而且每次等待时长也不小的时候，我们就需要show p分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。
```



4.3.5优化建议

1. 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。
2. 合理设计索引，尽量缩小锁的范围。
3. 尽可能较少检索条件，避免间隙锁。
4. 尽量控制事务大小，减少锁定资源量和时间长度。
5. 尽可能低级别事务隔离。

### 4.4 表锁(偏读)

偏向**MyISAM**存储引擎，开销小，加锁块；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

```sql
#手动增加表锁
lock table [表名字] read(write),[表名字2] read(write),[其他...];

#查看加过的锁
show open tables

#解锁(ALL)
unlock tables;

#分析表锁定
show status like 'table%'
#两个变量
#Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加一。
#Table_locks_waited：出现表级锁定争用而发生等待的次数。此值高说明存在着较严重的表级锁征用情况。
```

加上读锁后，当前session和其他session都能够对表进行读操作，但**==当前==**session不能读取其他表。当前session不能对表进行写操作，其他session若对表进行写操作则会一直**==阻塞==**直到读锁被释放(获得锁)。

加上写锁后，当前session能够对表进行读和写的两种操作，但当前session同样不能读取其他表。其他的session能够读取其他表，但读取加锁表是就会==**阻塞**==，写锁就更不能进行。



总而言之，读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。

MyISAM的读写锁调度是写优先，这也是MyISAM不适合做写为主表的引擎。因为写锁后，==**其他线程不能做任何操作**==，大量的更新会使查询很难得到锁，从而造成永远阻塞。



4.5 页锁

开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

---







































## 5 主从复制



























