## 基本定义

一种不严格的平衡二叉查找树。

一颗红黑树应该满足：

- 根节点是**黑**色的。
- 叶子结点都是**黑**的空结点，不存储数据。
- 直接相连的结点不能都为<span style="color:red;font-weight:bold">红色</span>。
- 每个结点到它可达的叶子节点的所有路径，包含相同数目得到**黑色**节点。



## 近似平衡

平衡的意思可以等价为性能不退化。近似平衡就可以等价为性能不会退化的太严重。

与AVL树的比较：

- AVL树的时间复杂度优于红黑树，但现在cpu太快可以忽略性能差异。
- 红黑树的插入删除更便于操作。
- 红黑树的性能优于AVL树(旋转情况少)。



## 实现

### 插入操作的平衡调整

插入的结点必须是红色的！

如果插入结点的父节点是黑色，就不需要改动。如果插入的当前结点是根节点，就直接变成黑色。



一般插入结点的父节点为红色时才需要改动。

#### 调整（旋转和变色）

每一次调整后，需要不断地迭代调整，因为每一次调整都会使得父节点可能会失去平衡。



##### 情况1：当前节点为红，叔叔结点也为红

把父节点和叔叔结点都设置为黑色祖父结点设置为红色。



##### 情况2：当前节点为红，叔叔结点为黑

此情况分为当前结点是右孩子还是左孩子。

右孩子：围绕父节点左旋。**当前节点变为父节点**。

左孩子：围绕==祖父==节点右旋。父节点变黑，祖父结点变红。

+++

### 删除操作的平衡调整

按照二叉查找树的方式删除。如果左右子树都不为空，删除后找到右子树中序遍历的第一个结点替代删除的结点。

==如果删除的是**黑色**的结点，原红黑树的性值才可能发生改变==。



从被删节点后来**顶替它的那个节点**开始调整，并认为它有**额外的一重黑色**。如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。有了这重额外的黑色，原红黑树性质5就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。



- 情况1：当前节点是红+黑，直接变黑，结束。
- 情况2：当前节点是双黑并且是根节点，直接结束。





- 情况3：当前节点是双黑，兄弟节点为<span style="color:red;">**红色**</span>。把父节点染成红色，把兄弟结点染成黑色。当前节点不变，**重新判断**。
- 情况4：当前节点双黑，兄弟节点和它的子节点全是黑。把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，**重新判断**。
- 情况5：当前节点双黑，兄弟节点为黑，兄弟节点左子为红，右子为黑。把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后**重判断**。
- 情况6：当前节点双黑，兄弟节点是黑色，但是兄弟节点的右子是红色。把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋，此时**算法结束**，红黑树所有性质调整正确。





