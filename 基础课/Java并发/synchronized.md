# Introduction

早期属于重量级锁。因为监视器锁monitor依赖于底层OS的Mutex Lock来实现。如果要挂起或唤醒一个线程，都需要操作系统切换到内核态帮助完成。



尽量不要让`synchronized`关键字给String加锁，因为JVM中的字符串常量池具有缓存功能。



+++



# 底层原理

底层属于JVM层面。

## 修饰语句块

使用的是`monitorenter`和`monitorexit`指令，分别指向同步块开始的位置和同步块结束的位置。当执行`monitorenter`指令的时候，线程试图获取锁(对象监视器`monitor`)的持有权。

> 在JVM中，每个对象中都内置了一个 `ObjectMonitor`对象。
>
> `wait/notify`等方法依赖于`monitor`对象，这就是为什么只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因。



## 修饰方法

与修饰代码块不同，修饰方法时，使用的是`ACC_SYNCHRONIZED`标识，标识该方法是一个同步方法，从而执行相应的同步调用。

==修饰方法与修饰代码块的本质都是对对象监视器`monitor`的获取==。



---





# JDK1.6之后的synchronized关键字的优化

JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

### 偏向锁

使用锁的==线程只有一个==时触发，在锁无竞争的情况下使用。偏向于第一个访问锁的线程，这种情况下是不需要同步的。如果在运行的过程中遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM消除偏向锁并将锁升级到标准的轻量级锁。整个偏向锁的获取过程最多只会执行一次CAS。

**获取过程**：

1. 访问MarkWord中偏向锁的状态，确认为可偏向状态。
2. 如果是可偏向状态，测试线程ID是否指向当前线程，是就执行同步代码。
   1. 未指向则通过CAS竞争锁。成功就执行同步代码。
      1. CAS未成功表示有竞争，不能使用偏向锁。到达全局安全点时，本来持有偏向锁的线程被挂起，偏向锁升级为轻量级锁。然后继续往下执行。

**释放**：只有遇到其他线程尝试竞争偏向锁时，持有锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销需要等待全局安全点。撤销后标志位需要恢复到未锁定01或轻量级锁00的状态。

### 轻量级锁

由偏向锁升级而来

 ### 重量级锁

：synchronized实现。

