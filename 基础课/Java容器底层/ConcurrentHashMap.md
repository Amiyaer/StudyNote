# JDK1.7

## 存储结构

Java7：JDK7中ConcurrentHashMap的存储结构是由很多个Segment段组合而成。==**每一个Segment段的结构类似于HashMap**==。默认的段个数是16，可以认为ConcurrentHashMap默认支持最多16个线程并发。

<img src="pic/ConcurrentHashMap.png" width="500px">





## 初始化

无参构造：会调用有参构造，传入三个参数的默认值：默认初始化容量16、默认负载因子0.75f、默认并发级别16。

有参构造：

* 进行参数校验。
* 校验并发级别的大小，大于最大值就会重置为最大值。
* 大于等于并发级别的最小的**2的幂次方**值作为初始化容量大小，默认为16。
* 记录`segmentShift`偏移量→`N`。默认为`32-sshift=28`。
* 记录`segmentMask`，默认是`ssize-1=16-1=15`。
* 初始化`segment[0]`，也就是第一个HashMap结构，默认大小为2，负载因子是0.75，插入第二个值时就会发生扩容。





## `put`方法

1.判断put的value不为空后，计算key对应的哈希值。

2.哈希值无符号右移`segmentShift`位(其实就是取高四位)，然后和`segmentMask`做与运算。

3.根据2得到的值(哪个Segment)去查找key是否已有Segment，如果没有就会调用`ensureSegment`初始化一个`Segment<K,V>`。

4.调用`Segment<K,V>`的put方法。



### `ensureSegment()` 

初始化一个`Segment`的方法。

1. 首先检查要初始化的位置的`Segment`是否为空，为空才进行初始化。
2. 使用0号`Segment`的初始化长度和负载因子创建`HashEntry`数组(所有`Segment`的初始化长度和负载因子都是一样的)。并计算扩容阈值。
3. 再次检查u(哈希值计算得到)位置的`Segment`是否为`null`，因为这时可能**==有其他线程进行了操作==**。
   1. 不为空直接返回。
   2. 为空的话，说明其他线程没有对其修改。此时使用**==CAS==**操作对当前`Segment`进行赋值，同时**==自旋==**判断当前位置的`Segment`是否为`null`，如果判断到不为空就直接返回了。



### `Segment<K,V>`的`put()`方法。

整个操作在`ReentrantLock`下进行，方法执行完成后才会释放锁，返回替换的旧值或`null`。由于`Segment`继承了`ReentrantLock`，所以`Segment`内部可以很方便的获取锁，`put`流程就用到了这个功能。

1. 首先尝试获取`ReentrantLock`独占锁，如果获取不到将会**调用`scanAndLockForPut(key,hash,value)`**来获取。

2. 计算`put`的位置(当前段的`HashEntry`数组的下标)。使用==**CAS**==获取相应坐标上的`HashEntry`。

3. 在2中获取的`HashEntry`非空的情况下，查看`key`是否已经存在。

   1. 如果已经存在，遍历当前链表找到并替换它。
   2. 如果不存在(也非空)，说明有冲突，使用==拉链头插法==。当前插入点`node.setNext(first);`并让其初始化。
      1. 插入完成后需要判断当前段的容量是否大于阈值，如果大于就需要扩容`rehash()`。
      2. 如果不需要扩容，就把`node`设置为当前`index`下标的节点。

   如果这个位置上的**HashEntry不存在**：

   1. 如果当前容量大于扩容阀值，小于最大容量，**进行扩容**。
   2. 直接**头插法**插入。





### `scanAndLockForPut()`方法

这个方法做的操作就是不断的自旋 `tryLock()` 获取锁。当自旋次数大于指定次数时，使用 `lock()` 阻塞自身，直到获取锁。在自旋时顺表获取下`hash`位置的`HashEntry`。

自旋的过程中，第一次自旋还会判断当前插入`index`是否为空，如果为空会帮助初始化。







## 扩容`rehash()`方法

扩容会扩到原来的两倍。老数组里的数据移动到新的数组时，==位置要么不变，要么变为index+oldSize==，参数里的node会在扩容之后使用链表**头插法**插入到指定位置。

1. 计算新的掩码`sizeMask = newCapacity - 1`。
2. 遍历老数组，每一个数组的链表中的每一个元素都要遍历。计算它们在新数组中的下标`idx = e.hash & sizeMark`。并将值移到新数组中。
   1. 如果当前旧位置的`HashEntry`还不是链表就直接赋值。
   2. 如果当前旧位置`HashEntry`已经变成了链表，它的每个`next`节点都要重新取哈希值并转移到新的数组中去。这里会用一个`LastRun`表示**最后连续相同新下标**的链表节点头，所以遍历完成后直接把这个点赋值到新位置，再把其他元素转移。







---

---

---





# JDK1.8

## 结构

JDK1.8使用的是`Node数组+链表/红黑树`的结构，类似于JDK1.8的`HashMap`。

<img src="pic/java8_concurrenthashmap.png" width="500px">





## 初始化`initTable()` 

初始化一个`Node`类型的数组`tab`。并使用一个变量** `sizeCtl` **来决定当前的初始化状态。

1. -1 说明正在==初始化==  。
2. -N 说明有N-1个线程正在进行==扩容== 。
3. 表示 table 初始化大小，如果table没有初始化(table在第一次put的时候才会初始化)。
4. 表示 table 扩容容量(阈值)，如果table已经初始化。

整个创建过程在自旋的情况下完成：

1. 首先判断sizeCtl的值来确定是否有其他的线程==CAS==成功，如果有的话就`Thread.yield()`让出CPU。否则就通过自己==CAS==去获取新建tab数组，分配容量等。
2. 创建成功后要修改`sizeCtl=sc`表示自己==CAS==成功。







## `put()`方法

类似于`HashMap`，这里的put方法直接调用了`putVal()`方法。下面是`putVal()`方法的流程。这里会声明一个`binCount`，来计算插入位置上的节点数是否大于阈值，需要转化为红黑树。

1. 首先判断`key`和`value`是否为空，在他们不为空的情况下。获得`key`的哈希值，这个哈希值由于算法，一定是一个**正数**。
2. 查看tab数组是否为空。使用的`tabAt()`查看元素的方法会调用`getObjectVolatile()`，是一个本地方法，~~使用了==volatile==关键字~~。使用`f`表示put的位置的`Node`元素。`fh`保存它的哈希值。
   1. 如果为空这里就初始化一个(==CAS+自旋==)。
   2. 不为空但是对应的下标的`Node<K,V>`为空，通过==CAS==操作`casTabAt`放入元素，成功后break。
   3. `Node<K,V>`也不为空，此时先通过`(fh = f.hash) == MOVED`判断当前插入的位置是否正在扩容(元素已经被移动)，如果正在扩容就**协助扩容**，而不是添加元素。
   4. 使用`synchronized`加锁(仅仅对当前数组上的元素f加锁) 来进行元素的添加或替换。不会影响数组其他元素的添加。
      1. `fh>=0`，说明`Node`的哈希值大于0，是链表，此时循环加入新的节点或者覆盖已有的节点。遍历的同时`bincount++`，计算链表长度。
      2. `f instanceof TreeBin`，说明`Node`是红黑树，`bincount`固定为2。调用红黑树的方法插入新的节点。
   5. 最后判断`binCount`是否大于阈值(是否需要转化为红黑树)以及是否发生了替换。如果发生的是替换而不是插入就返回旧值。





## 扩容

### 1.`addCount()`方法计数

用于计算map中存放了多少元素。这里会使用一个数组`counterCell`，如果无法对变量进行添加，就会对数组里的某一个位置的元素进行添加。最后计算变量和数组的总和。













