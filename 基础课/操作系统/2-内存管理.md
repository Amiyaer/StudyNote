# 内存管理

概念：操作系统对于内存空间的合理划分和分配。

功能：包括内存空间的分配与回收、地址转换(逻辑↔物理)、内存空间的扩充(逻辑上)、存储保护等。



## 程序的装入和链接

将用户程序变为可以在内存中执行的程序。

通常需要经过几个步骤：

* 编译：将源码编译成若干模块。

* 链接：把目标模块和所需的库函数链接成一个完整的装入模块

* 装入：装入模块被装入内存中运行。



### 静态链接

在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不在拆开。

静态链接器以一组==可重定位目标文件==为输入，生成一个完全链接的可执行文件作为输出。链接器主要完成以下两个任务：

- 符号解析：将每个符号(对应函数、全局变量、静态变量)的引用与一个符号定义关联起来。
- 重定位：把符号定义与内存位置关联起来，然后修改符号的引用，使它们指向内存位置。



### 动态链接

静态库存在的问题：静态库更新时整个程序都要重新进行链接；对于某些标准函数库，如果每个程序都要使用，会造成极大浪费资源。



装入时动态链接：装入模块在装入内存时，采用边装入边链接的方式。

运行时动态链接：当程序在执行的过程中需要模块时才进行链接。这样便于修改和更新，便于实现对目标模块的共享。



### 逻辑地址空间和物理地址空间

编译后的每个目标模块都从0号单元开始编址，这就是目标模块的`相对地址`，也成为`逻辑地址`。各个模块在链接完成后，链接程序按照各个模块的顺序构成统一的`逻辑地址空间`。用户程序和程序员只知道逻辑地址。

`物理地址`空间指的是==内存中==物理单元的集合，是地址转换的最终地址。进程在运行的时候执行指令和访问数据，最后都要通过物理内存地址从主存中存取。可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为`地址重定位`。

---









## 内存管理方式

覆盖：把用户空间分为固定区和若干覆盖区。最常访问的部分放在固定区；即将访问的部分放入覆盖区；其他的段放在外存中，需要调用时再调入覆盖区，替换覆盖区原有的段。

内存中能够更新的地方只有覆盖区的段。



交换：`换出`把处于等待状态的程序移动到辅存，腾出内存空间；`换入`把准备好竞争CPU运行的程序从辅存移到内存。



### 连续分配管理方式(块式管理)

概念：为一个用户程序分配一个连续的内存空间。

三种方式：

- 单一连续分配：内存分为系统区和用户区。系统区仅供操作系统使用，用户区为用户提供。这种方式无需进行内存保护，因为内存只有一道程序。
  - 只能用于单用户、单任务的操作系统，存储器利用率低。
- 固定分区分配：将用户内存空间划分为若干固定大小的区域，==每个分区只装入一道作业==。有空闲分区时就可以从外存选取合适大小的作业装入，分区的大小可以相等也可以不相等。
  - 程序可能太大而放不下任何一个分区，这时就要使用覆盖技术。
  - 存在内部碎片。
- 动态分区分配：在进程装入内存时，根据进程的大小动态地建立正好合适大小的分区。
  - 开始时是好的，随着时间的推移内存中会出现越来越多的碎片。bad

动态分配算法(切换进程时)

首次适应：找到大小能满足要求的第一个空闲分区。**(适应效果最好)** 

最佳适应：找到能满足的最小分区。

最坏适应：找到能满足的最大分区。

临近适应：由首次适应算法演变而成，不同的是每次从上次查找结束的位置开始继续查找。





### 非连续分配管理方式

允许一个程序分散装入不连续的内存分区。当然，也需要额外的空间去存储它们的索引。

根据分区大小是否固定，分为分页存储管理和分段存储管理。



#### 1.基本分页存储管理方式

把主存空间划分为大小相等且固定的块(相对较小)，作为主存的基本单位。进程也以块为单位进行划分，执行时以块为单位逐个申请主存中的块空间。

不会产生外部碎片，且只会在为最后一个不完整的块申请空间时才会产生主存碎片。

##### 1.1几个基本概念

- 进程中的块称为页，内存中的块称为页框或页帧(Page Frame)。外存中则直接称为块。
- 页面的大小应该为`2的整数幂`。
- 分页存储地址结构：包含两部分，页号P和页内偏移量W。地址长度32位，0~11位为业内地址，12到31位为页号(最多允许2^20^页)。地址结构决定了虚拟内存的寻址空间有多大。
- 页表：实现页号到物理块号的地址映射。一个进程对应一张页表。记录页面在内存中对应的物理块号，页表一般存放在内存中。页表项也含有页号，除此之外，页表项还包括了块号，这个块号是物理内存中的块号，与地址结构的业内偏移不同。进程执行时，通过该表就可以查到每页在内存中的物理块号。

<img src="https://bkimg.cdn.bcebos.com/pic/377adab44aed2e7341d4f11e8301a18b87d6fac7" width="250">

* 基本地址变换结构：逻辑地址→物理地址。
* 两级页表：将页表的10页空间也进行映射，进程执行时只需将这一页的上一级页表调入内存中。如果采用这种多级页表机制，各级页表的大小不能超过一个页面。



##### 1.2 快表

可以理解为一种特殊的高速缓存器，其中的内容是页表的一部分或者全部内容。作为页表的Cache，它的作用和页表相似，但是提高了访问的速率。由于采用页表做地址转换，读写内存要访问两次。有了快表，可以加速查找。

使用快表的地址转换流程：(很像redis)

+ 根据虚拟地址的页号查找快表；
+ 查到了就直接去找物理地址；
+ 没查到就访问内存中的页表，再从页表中得到物理地址，同时把映射关系添加到快表里；
+ 快表满了就按照一定的淘汰策略淘汰掉快表中的一个页。



#### 2.基本分段存储管理方式

##### 分段

按照用户进程中的自然段划分逻辑空间。比如一个进程的主程序、子程序、栈和一段数据，就可以分别分成独立的段，并分配地址空间。段内要求地址空间连续，而段间并不要求地址空间连续。==**分段的长度是不固定的**==。

一个作业的逻辑地址由段号S与段内偏移量W两部分组成。这些都是由用户提供的。

##### 段表

在逻辑空间与内存空间映射，由**段号、段长、本段在主存的始址**组成。其余管理方式类似于分页管理。



#### 3.段页式管理方式

作业的地址空间首先被分成若干逻辑段，然后将每一段分成固定大小的页。

作业的逻辑地址被分为段号、页号、页内偏移量三部分。

系统为每个进程建立一张段表，每个分段有一张页表。段表表项中有段号、页表长度和页表地址，页表表项中至少包括页号和块号。

同样，系统中有一个段表寄存器，指出作业的段表起始地址和段表的长度。

---







## 虚拟内存管理

局部性原理：表现在两个方面

* `时间局部性`。程序中的某条指令一旦执行，不久后该指令可能再次执行；某数据被访问后不久可能再被访问。产生这种局部性的典型原因是程序中的循环语句。
* `空间局部性`。一旦程序访问了某个存储单元。不久后其附近的存储单元也可能被访问。



虚拟存储器：访问的信息不在内存时，由操作系统将所需要的部分调入内存执行，暂时不使用的部分换出到外存上，腾出空间。

三个特性：

* 多次性。程序无需在作业运行时一次性全部装入内存。
* 对换性。允许在作业的运行中换入换出。
* 虚拟性。逻辑上扩充内存，使用户看到的内存远大于实际内存。



### 虚拟内存

不采用连续分配的方式，会使得相当一部分内存空间都处于暂时或永久空闲状态。

实现方式：请求分页存储管理、请求分段存储管理、请求段页式存储管理。

需要的支持：一定的内存与外存；页表机制，作为主要数据结构；中断机制，用于调入访问的部分；地址变换结构。



### 请求分页管理方式

建立在基本分页系统基础之上，是目前最常用的一种实现虚拟存储器的方法。

只要求将当前需要的一部分页装入内存，在执行过程中如果需要其他页，再通过调页功能调入。

#### 请求分页系统的页表机制

不同于基本分页系统，请求页的表项中增加了4个字段。

页表项的组成：

* 页号
* 物理块号
* 状态位P：该页是否已经调入内存。
* 访问字段A：记录本页在一段时间内被访问的次数，或者已有多长时间未被访问。
* 修改位M：标识该页在调入内存后是否被修改过。
* 外存地址：该页在外存上的地址，通常是物理块号。

#### 缺页中断

缺页中断：要访问的页不在内存内，此时产生一个缺页中断，操作系统将缺少的页调入内存。

在执行期间产生和处理中断信号，属于内部中断。

一条指令执行期间可能产生多次缺页中断。

#### 地址变换

进行地址变换时，先检查快表，如果找到访问的页，则修改页表中的访问位，若是写指令还要重置修改位，然后利用表项的物理块号和页内地址形成物理地址。

若未找到页表项，到内存中去查找页表，对比状态位P，看其是否已调入内存，未调入就产生缺页中断，请求从外存把其调入内存。

---



### ==页面置换算法==

选择调出页面的算法

#### 1.最佳(OPT)置换算法

选择淘汰的页面是在==最长时间内不再被访问==的页面。暂时无法实现。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190105161243206.png)

#### 2.先进先出(FIFO)页面置换算法

~

#### 3.最近最久未使用(LRU)置换算法

选择最近最长时间未访问的页面淘汰。性能较好，但是需要寄存器和栈的硬件支持。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190105161257879.png)

#### 4.最少使用(LFU)置换算法

选择之前使用次数最少的页面淘汰。

#### *5.时钟(CLOCK)算法

也称为最近未使用算法(NRU)。

给每帧关联一个附加位，称之为访问位。内存中的页面通过指针链接成一个循环队列。某页首次被装入内存块时，把访问位置为1，根据指针去找下一个。产生缺页中断、需要换页时，检查当前时钟页的访问位，如果是0就直接换出，是1就置为0，然后==跳过==。找到第一个访问位为0的页，进行置换。

##### 改进

优先淘汰没有修改过的页面。

除了访问位，==额外增加一个修改位==。

同样，所有可能被置换的页面排成一个循环队列。

第一轮从当前位置扫描到第一个(0，0)的帧用于替换，本轮不修改。

第一轮没找到的话，第二轮找第一个没被访问但是被修改过的帧用于替换，本轮把访问位设置为0。

第二轮失败的话，第三轮找(0，0)的帧。

第三轮失败，第4轮再找（0，1）的帧。

四轮一定能够找到一个能用的帧。









## 一些其他概念

**内存映射**：Linux内核提供的一种访问磁盘文件的特殊方式。**将内存中的某块地址空间和我们要指定的磁盘文件相关联，从而把对内存的访问转换为对磁盘文件的访问**。**这两个空间的数据是共享的**。==这样做的好处是减少数据从内核空间到用户空间缓存的数据复制操作，同时又可以达到很快的访问速度==。使用内存映射处理存储在磁盘上的文件时，将不必再对文件执行IO操作，**取消了文件数据加载到内存、数据从内存到文件的回写以及释放内存块等步骤**。

共享型：将任何对内存的写操作都同步到磁盘文件，所有映射同一个文件的进程都共享任意一个进程对映射内存的修改。

私有型：映射文件只能是读文件，不能将对内存的写同步到文件，多个进程不共享修改。



**缓存IO(标准IO)**：先将磁盘复制到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。读操作需要先检查内核的缓冲区有没有数据，如果没有就要从磁盘中读取；写操作直接把数据从用户空间复制到内核空间，什么时候能写到磁盘中由操作系统决定。

**直接IO**：应用程序直接访问磁盘数据，不经过内核缓冲区。如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘加载，效率很低。(选用的原因是，应用更倾向于使用自己的缓存机制)。











