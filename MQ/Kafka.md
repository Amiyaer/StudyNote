Kafka：一个基于分布式的基于<font color=red>**发布/订阅模式**</font>的消息队列，主要用于大数据实时处理领域。



**消息队列的两种模式**：

* 点对点模式：一对一。生产者生产消息到Queue中，然后消息消费者从Queue中主动取出并消费消息，消息收到后**消息清除**。如果想让多个消费者接收相同的消息，需要发送到多个消息队列中。
* **发布/订阅模式**：一对多。消息生产者将消息发布到topic中，同时有多个消息消费者消费(订阅)该消息。发布到topic的消息会被所有订阅者消费。消费者消费数据之后不会清除消息。**发布/订阅模式**也有两种方式：消费者主动拉取和生产者主动推送消息。Kafka属于消费者主动拉取(消费者的速度可以由消费者自己决定)。



### Kafka基础架构

**1.生产者生产消息** 

往某个topic上发布消息。生产者也负责选择发布到topic上的哪一个分区。最简单的是轮流选择。



**2.Kafka==集群==管理消息** 

每一个Kafka集群都是一个Broker(代理)，相当于一个启动Kafka进程的服务器。每一个Broker中还建立了不同的主题**Topic**，相当于是把消息做了一个**分类**。生产者和消费者可以连接主题来进行消息发送。

Topic是发布的消息的类别名，一个topic可以有0至多个消费者订阅该主题的消息。对于每个topic，Kafka集群都会**维护一个==分区log==**。

<img src="pic/Kafka分区.png"/>

每一个分区都是一个顺序的、不可变的消息队列，并且可以持续的添加。分区中的消息都被分了一个序列号，称之为偏移量offset(每个消费者持有一个offset，作为他们各自消费到哪里的**记录**)。

无论消息是否被消费，Kafka保存所有的消息**直到他们过期**。消费者所持有的仅有的元数据就是offset。消费者消费消息的时候，偏移量也线性的增加，消费者也可以将偏移量重置为更早的位置，重新读取消息。

<img src="pic/分区.png" style="zoom: 20%;" />

**为什么分区**：更多的分区可以处理更多的消息，不受单台服务器的限制；分区可以作为并行处理的单元。

每一个分区有一个leader，若干个follower。leader处理当前分区的**读写请求**，follower进行**数据的复制**。leader宕机时，**==？其他分区==**的一个follower会被推举为新的leader。 一台服务器可能同时是一个分区的leader，另一个分区的follower。 这样可以平衡负载，<u>避免所有的请求都只让一台或者某几台服务器处理</u>。



**3.消费者消费消息** 

Kafka提供了消费者组，消费者用一个消费者组名标记自己。一个发布在topic上的消息被分发给消费者组中的一个消费者。假如所有的消费者都在一个组中，那么这就变成了queue模型。 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。

**==Topic分区中消息只能由消费者组中的唯一一个消费者处理==**。



**4.Zookeeper注册消息** 



### Kafka的保证(Guarantees)

- 生产者发送到一个特定的Topic的分区上，消息将会按照它们<font color=blue>**发送的顺序依次加入**</font>，也就是说，如果一个消息M1和M2使用相同的producer发送，M1先发送，那么M1将比M2的offset低，并且优先的出现在日志中。
- 消费者收到的消息也是此顺序。
- 如果一个Topic配置了复制因子（replication factor）为N， 那么可以允许N-1服务器宕机而不丢失任何已经提交（committed）的消息。

